<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Trevor Perrin (noise@trevp.net)" />
  <meta name="date" content="2018-07-11" />
  <title>The Noise Protocol Framework</title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="spec_markdown.css" type="text/css" />
</head>
<body>
<div id="header">
<h1 class="title">The Noise Protocol Framework</h1>
<b>Author:</b> Trevor Perrin (noise@trevp.net)<br/>
<b>Revision:</b> 34<br/>
<b>Date:</b> 2018-07-11<br/>
<b>Status:</b> official/unstable<br/>
<b>PDF:</b> <a href="noise.pdf">noise.pdf</a><br/>
</div>
<div id="TOC">
<h2 class="toc">Table of Contents</h2>
<ul>
<li><a href="#introduction">1. Introduction</a></li>
<li><a href="#overview">2. Overview</a><ul>
<li><a href="#terminology">2.1. Terminology</a></li>
<li><a href="#overview-of-handshake-state-machine">2.2. Overview of handshake state machine</a></li>
</ul></li>
<li><a href="#message-format">3. Message format</a></li>
<li><a href="#crypto-functions">4. Crypto functions</a><ul>
<li><a href="#dh-functions">4.1. DH functions</a></li>
<li><a href="#cipher-functions">4.2. Cipher functions</a></li>
<li><a href="#hash-functions">4.3. Hash functions</a></li>
</ul></li>
<li><a href="#processing-rules">5. Processing rules</a><ul>
<li><a href="#the-cipherstate-object">5.1. The <code>CipherState</code> object</a></li>
<li><a href="#the-symmetricstate-object">5.2. The <code>SymmetricState</code> object</a></li>
<li><a href="#the-handshakestate-object">5.3. The <code>HandshakeState</code> object</a></li>
</ul></li>
<li><a href="#prologue">6. Prologue</a></li>
<li><a href="#handshake-patterns">7. Handshake patterns</a><ul>
<li><a href="#handshake-pattern-basics">7.1. Handshake pattern basics</a></li>
<li><a href="#alice-and-bob">7.2. Alice and Bob</a></li>
<li><a href="#handshake-pattern-validity">7.3. Handshake pattern validity</a></li>
<li><a href="#one-way-handshake-patterns">7.4. One-way handshake patterns</a></li>
<li><a href="#interactive-handshake-patterns-fundamental">7.5. Interactive handshake patterns (fundamental)</a></li>
<li><a href="#interactive-handshake-patterns-deferred">7.6. Interactive handshake patterns (deferred)</a></li>
<li><a href="#payload-security-properties">7.7. Payload security properties</a></li>
<li><a href="#identity-hiding">7.8. Identity hiding</a></li>
</ul></li>
<li><a href="#protocol-names-and-modifiers">8. Protocol names and modifiers</a><ul>
<li><a href="#handshake-pattern-name-section">8.1. Handshake pattern name section</a></li>
<li><a href="#cryptographic-algorithm-name-sections">8.2. Cryptographic algorithm name sections</a></li>
</ul></li>
<li><a href="#pre-shared-symmetric-keys">9. Pre-shared symmetric keys</a><ul>
<li><a href="#cryptographic-functions">9.1. Cryptographic functions</a></li>
<li><a href="#handshake-tokens">9.2. Handshake tokens</a></li>
<li><a href="#validity-rule">9.3. Validity rule</a></li>
<li><a href="#pattern-modifiers">9.4. Pattern modifiers</a></li>
</ul></li>
<li><a href="#compound-protocols">10. Compound protocols</a><ul>
<li><a href="#rationale-for-compound-protocols">10.1. Rationale for compound protocols</a></li>
<li><a href="#the-fallback-modifier">10.2. The <code>fallback</code> modifier</a></li>
<li><a href="#zero-rtt-and-noise-protocols">10.3. Zero-RTT and Noise protocols</a></li>
<li><a href="#noise-pipes">10.4. Noise Pipes</a></li>
<li><a href="#handshake-indistinguishability">10.5. Handshake indistinguishability</a></li>
</ul></li>
<li><a href="#advanced-features">11. Advanced features</a><ul>
<li><a href="#dummy-keys">11.1. Dummy keys</a></li>
<li><a href="#channel-binding">11.2. Channel binding</a></li>
<li><a href="#rekey">11.3. Rekey</a></li>
<li><a href="#out-of-order-transport-messages">11.4. Out-of-order transport messages</a></li>
<li><a href="#half-duplex-protocols">11.5. Half-duplex protocols</a></li>
</ul></li>
<li><a href="#dh-functions-cipher-functions-and-hash-functions">12. DH functions, cipher functions, and hash functions</a><ul>
<li><a href="#the-25519-dh-functions">12.1. The <code>25519</code> DH functions</a></li>
<li><a href="#the-448-dh-functions">12.2. The <code>448</code> DH functions</a></li>
<li><a href="#the-chachapoly-cipher-functions">12.3. The <code>ChaChaPoly</code> cipher functions</a></li>
<li><a href="#the-aesgcm-cipher-functions">12.4. The <code>AESGCM</code> cipher functions</a></li>
<li><a href="#the-sha256-hash-function">12.5. The <code>SHA256</code> hash function</a></li>
<li><a href="#the-sha512-hash-function">12.6. The <code>SHA512</code> hash function</a></li>
<li><a href="#the-blake2s-hash-function">12.7. The <code>BLAKE2s</code> hash function</a></li>
<li><a href="#the-blake2b-hash-function">12.8. The <code>BLAKE2b</code> hash function</a></li>
</ul></li>
<li><a href="#application-responsibilities">13. Application responsibilities</a></li>
<li><a href="#security-considerations">14. Security considerations</a></li>
<li><a href="#rationales">15. Rationales</a><ul>
<li><a href="#ciphers-and-encryption">15.1. Ciphers and encryption</a></li>
<li><a href="#hash-functions-and-hashing">15.2. Hash functions and hashing</a></li>
<li><a href="#other">15.3. Other</a></li>
</ul></li>
<li><a href="#ipr">16. IPR</a></li>
<li><a href="#acknowledgements">17. Acknowledgements</a></li>
<li><a href="#appendices">18. Appendices</a><ul>
<li><a href="#deferred-patterns">18.1. Deferred patterns</a></li>
<li><a href="#security-properties-for-deferred-patterns">18.2. Security properties for deferred patterns</a></li>
<li><a href="#pattern-derivation-rules">18.3. Pattern derivation rules</a></li>
<li><a href="#change-log">18.4. Change log</a></li>
</ul></li>
<li><a href="#references">19. References</a></li>
</ul>
</div>
<h1 id="introduction">1. Introduction</h1>
<p>Noise is a framework for crypto protocols based on Diffie-Hellman key agreement. Noise can describe protocols that consist of a single message as well as interactive protocols.</p>
<h1 id="overview">2. Overview</h1>
<h2 id="terminology">2.1. Terminology</h2>
<p>A Noise protocol begins with two parties exchanging <strong>handshake messages</strong>. During this <strong>handshake phase</strong> the parties exchange DH public keys and perform a sequence of DH operations, hashing the DH results into a shared secret key. After the handshake phase each party can use this shared key to send encrypted <strong>transport messages</strong>.</p>
<p>The Noise framework supports handshakes where each party has a long-term <strong>static key pair</strong> and/or an <strong>ephemeral key pair</strong>. A Noise handshake is described by a simple language. This language consists of <strong>tokens</strong> which are arranged into <strong>message patterns</strong>. Message patterns are arranged into <strong>handshake patterns</strong>.</p>
<p>A <strong>message pattern</strong> is a sequence of tokens that specifies the DH public keys that comprise a handshake message, and the DH operations that are performed when sending or receiving that message. A <strong>handshake pattern</strong> specifies the sequential exchange of messages that comprise a handshake.</p>
<p>A handshake pattern can be instantiated by <strong>DH functions</strong>, <strong>cipher functions</strong>, and <strong>hash functions</strong> to give a concrete <strong>Noise protocol</strong>.</p>
<h2 id="overview-of-handshake-state-machine">2.2. Overview of handshake state machine</h2>
<p>The core of Noise is a set of variables maintained by each party during a handshake, and rules for sending and receiving handshake messages by sequentially processing the tokens from a message pattern.</p>
<p>Each party maintains the following variables:</p>
<ul>
<li><p><strong><code>s, e</code></strong>: The local party's static and ephemeral key pairs (which may be empty).</p></li>
<li><p><strong><code>rs, re</code></strong>: The remote party's static and ephemeral public keys (which may be empty).</p></li>
<li><p><strong><code>h</code></strong>: A <strong>handshake hash</strong> value that hashes all the handshake data that's been sent and received.</p></li>
<li><p><strong><code>ck</code></strong>: A <strong>chaining key</strong> that hashes all previous DH outputs. Once the handshake completes, the chaining key will be used to derive the encryption keys for transport messages.</p></li>
<li><p><strong><code>k, n</code></strong>: An encryption key <code>k</code> (which may be empty) and a counter-based nonce <code>n</code>. Whenever a new DH output causes a new <code>ck</code> to be calculated, a new <code>k</code> is also calculated. The key <code>k</code> and nonce <code>n</code> are used to encrypt static public keys and handshake payloads. Encryption with <code>k</code> uses some <strong>AEAD</strong> cipher mode (in the sense of Rogaway <span class="citation">[<a href="#ref-Rogaway:2002">1</a>]</span>) and uses the current <code>h</code> value as <strong>associated data</strong> which is covered by the AEAD authentication. Encryption of static public keys and payloads provides some confidentiality and key confirmation during the handshake phase.</p></li>
</ul>
<p>A handshake message consists of some DH public keys followed by a <strong>payload</strong>. The payload may contain certificates or other data chosen by the application. To send a handshake message, the sender specifies the payload and sequentially processes each token from a message pattern. The possible tokens are:</p>
<ul>
<li><p><strong><code>&quot;e&quot;</code></strong>: The sender generates a new ephemeral key pair and stores it in the <code>e</code> variable, writes the ephemeral public key as cleartext into the message buffer, and hashes the public key along with the old <code>h</code> to derive a new <code>h</code>.</p></li>
<li><p><strong><code>&quot;s&quot;</code></strong>: The sender writes its static public key from the <code>s</code> variable into the message buffer, encrypting it if <code>k</code> is non-empty, and hashes the output along with the old <code>h</code> to derive a new <code>h</code>.</p></li>
<li><p><strong><code>&quot;ee&quot;, &quot;se&quot;, &quot;es&quot;, &quot;ss&quot;</code></strong>: A DH is performed between the initiator's key pair (whether static or ephemeral is determined by the first letter) and the responder's key pair (whether static or ephemeral is determined by the second letter). The result is hashed along with the old <code>ck</code> to derive a new <code>ck</code> and <code>k</code>, and <code>n</code> is set to zero.</p></li>
</ul>
<p>After processing the final token in a handshake message, the sender then writes the payload into the message buffer, encrypting it if <code>k</code> is non-empty, and hashes the output along with the old <code>h</code> to derive a new <code>h</code>.</p>
<p>As a simple example, an unauthenticated DH handshake is described by the handshake pattern:</p>
<pre><code>  -&gt; e
  &lt;- e, ee</code></pre>
<p>The <strong>initiator</strong> sends the first message, which is simply an ephemeral public key. The <strong>responder</strong> sends back its own ephemeral public key. Then a DH is performed and the output is hashed into a shared secret key.</p>
<p>Note that a cleartext payload is sent in the first message, after the cleartext ephemeral public key, and an encrypted payload is sent in the response message, after the cleartext ephemeral public key. The application may send whatever payloads it wants.</p>
<p>The responder can send its static public key (under encryption) and authenticate itself via a slightly different pattern:</p>
<pre><code>  -&gt; e
  &lt;- e, ee, s, es</code></pre>
<p>In this case, the final <code>ck</code> and <code>k</code> values are a hash of both DH results. Since the <code>es</code> token indicates a DH between the initiator's ephemeral key and the responder's static key, successful decryption by the initiator of the second message's payload serves to authenticate the responder to the initiator.</p>
<p>Note that the second message's payload may contain a zero-length plaintext, but the payload ciphertext will still contain authentication data (such as an authentication tag or &quot;synthetic IV&quot;), since encryption is with an AEAD mode. The second message's payload can also be used to deliver certificates for the responder's static public key.</p>
<p>The initiator can send <em>its</em> static public key (under encryption), and authenticate itself, using a handshake pattern with one additional message:</p>
<pre><code>  -&gt; e
  &lt;- e, ee, s, es
  -&gt; s, se</code></pre>
<p>The following sections flesh out the details, and add some complications. However, the core of Noise is this simple system of variables, tokens, and processing rules, which allow concise expression of a range of protocols.</p>
<h1 id="message-format">3. Message format</h1>
<p>All Noise messages are less than or equal to 65535 bytes in length. Restricting message size has several advantages:</p>
<ul>
<li><p>Simpler testing, since it's easy to test the maximum sizes.</p></li>
<li><p>Reduces the likelihood of errors in memory handling, or integer overflow.</p></li>
<li><p>Enables support for streaming decryption and random-access decryption of large data streams.</p></li>
<li><p>Enables higher-level protocols that encapsulate Noise messages to use an efficient standard length field of 16 bits.</p></li>
</ul>
<p>All Noise messages can be processed without parsing, since there are no type or length fields. Of course, Noise messages might be encapsulated within a higher-level protocol that contains type and length information. Noise messages might encapsulate payloads that require parsing of some sort, but payloads are handled by the application, not by Noise.</p>
<p>A Noise <strong>transport message</strong> is simply an AEAD ciphertext that is less than or equal to 65535 bytes in length, and that consists of an encrypted payload plus 16 bytes of authentication data. The details depend on the AEAD cipher function, e.g. AES256-GCM, or ChaCha20-Poly1305, but typically the authentication data is either a 16-byte authentication tag appended to the ciphertext, or a 16-byte synthetic IV prepended to the ciphertext.</p>
<p>A Noise <strong>handshake message</strong> is also less than or equal to 65535 bytes. It begins with a sequence of one or more DH public keys, as determined by its message pattern. Following the public keys will be a single payload which can be used to convey certificates or other handshake data, but can also contain a zero-length plaintext.</p>
<p>Static public keys and payloads will be in cleartext if they are sent in a handshake prior to a DH operation, and will be AEAD ciphertexts if they occur after a DH operation. (If Noise is being used with pre-shared symmetric keys, this rule is different; see <a href="#pre-shared-symmetric-keys">Section 9</a>). Like transport messages, AEAD ciphertexts will expand each encrypted field (whether static public key or payload) by 16 bytes.</p>
<p>For an example, consider the handshake pattern:</p>
<pre><code>  -&gt; e
  &lt;- e, ee, s, es
  -&gt; s, se</code></pre>
<p>The first message consists of a cleartext public key (<code>&quot;e&quot;</code>) followed by a cleartext payload (remember that a payload is implicit at the end of each message pattern). The second message consists of a cleartext public key (<code>&quot;e&quot;</code>) followed by an encrypted public key (<code>&quot;s&quot;</code>) followed by an encrypted payload. The third message consists of an encrypted public key (<code>&quot;s&quot;</code>) followed by an encrypted payload.</p>
<p>Assuming each payload contains a zero-length plaintext, and DH public keys are 56 bytes, the message sizes will be:</p>
<ol style="list-style-type: decimal">
<li>56 bytes (one cleartext public key and a cleartext payload)</li>
<li>144 bytes (two public keys, the second encrypted, and encrypted payload)</li>
<li>88 bytes (one encrypted public key and encrypted payload)</li>
</ol>
<p>  </p>
<h1 id="crypto-functions">4. Crypto functions</h1>
<p>A Noise protocol is instantiated with a concrete set of <strong>DH functions</strong>, <strong>cipher functions</strong>, and <strong>hash functions</strong>. The signature for these functions is defined below. Some concrete functions are defined in <a href="#dh-functions-cipher-functions-and-hash-functions">Section 12</a>.</p>
<p>The following notation will be used in algorithm pseudocode:</p>
<ul>
<li>The <code>||</code> operator concatenates byte sequences.</li>
<li>The <code>byte()</code> function constructs a single byte.</li>
</ul>
<h2 id="dh-functions">4.1. DH functions</h2>
<p>Noise depends on the following <strong>DH functions</strong> (and an associated constant):</p>
<ul>
<li><p><strong><code>GENERATE_KEYPAIR()</code></strong>: Generates a new Diffie-Hellman key pair. A DH key pair consists of <code>public_key</code> and <code>private_key</code> elements. A <code>public_key</code> represents an encoding of a DH public key into a byte sequence of length <code>DHLEN</code>. The <code>public_key</code> encoding details are specific to each set of DH functions.</p></li>
<li><p><strong><code>DH(key_pair, public_key)</code></strong>: Performs a Diffie-Hellman calculation between the private key in <code>key_pair</code> and the <code>public_key</code> and returns an output sequence of bytes of length <code>DHLEN</code>. For security, the Gap-DH problem based on this function must be unsolvable by any practical cryptanalytic adversary <span class="citation">[<a href="#ref-gapdh">2</a>]</span>.</p>
<p>The <code>public_key</code> either encodes some value which is a generator in a large prime-order group (which value may have multiple equivalent encodings), or is an invalid value. Implementations must handle invalid public keys either by returning some output which is purely a function of the public key and does not depend on the private key, or by signaling an error to the caller. The DH function may define more specific rules for handling invalid values.</p></li>
<li><p><strong><code>DHLEN</code></strong> = A constant specifying the size in bytes of public keys and DH outputs. For security reasons, <code>DHLEN</code> must be 32 or greater.</p></li>
</ul>
<h2 id="cipher-functions">4.2. Cipher functions</h2>
<p>Noise depends on the following <strong>cipher functions</strong>:</p>
<ul>
<li><p><strong><code>ENCRYPT(k, n, ad, plaintext)</code></strong>: Encrypts <code>plaintext</code> using the cipher key <code>k</code> of 32 bytes and an 8-byte unsigned integer nonce <code>n</code> which must be unique for the key <code>k</code>. Returns the ciphertext. Encryption must be done with an &quot;AEAD&quot; encryption mode with the associated data <code>ad</code> (using the terminology from <span class="citation">[<a href="#ref-Rogaway:2002">1</a>]</span>) and returns a ciphertext that is the same size as the plaintext plus 16 bytes for authentication data. The entire ciphertext must be indistinguishable from random if the key is secret (note that this is an additional requirement that isn't necessarily met by all AEAD schemes).</p></li>
<li><p><strong><code>DECRYPT(k, n, ad, ciphertext)</code></strong>: Decrypts <code>ciphertext</code> using a cipher key <code>k</code> of 32 bytes, an 8-byte unsigned integer nonce <code>n</code>, and associated data <code>ad</code>. Returns the plaintext, unless authentication fails, in which case an error is signaled to the caller.</p></li>
<li><p><strong><code>REKEY(k)</code></strong>: Returns a new 32-byte cipher key as a pseudorandom function of <code>k</code>. If this function is not specifically defined for some set of cipher functions, then it defaults to returning the first 32 bytes from <code>ENCRYPT(k,    maxnonce, zerolen, zeros)</code>, where <code>maxnonce</code> equals 2<sup>64</sup>-1, <code>zerolen</code> is a zero-length byte sequence, and <code>zeros</code> is a sequence of 32 bytes filled with zeros.</p></li>
</ul>
<h2 id="hash-functions">4.3. Hash functions</h2>
<p>Noise depends on the following <strong>hash function</strong> (and associated constants):</p>
<ul>
<li><p><strong><code>HASH(data)</code></strong>: Hashes some arbitrary-length data with a collision-resistant cryptographic hash function and returns an output of <code>HASHLEN</code> bytes.</p></li>
<li><p><strong><code>HASHLEN</code></strong> = A constant specifying the size in bytes of the hash output. Must be 32 or 64.</p></li>
<li><p><strong><code>BLOCKLEN</code></strong> = A constant specifying the size in bytes that the hash function uses internally to divide its input for iterative processing. This is needed to use the hash function with HMAC (<code>BLOCKLEN</code> is <code>B</code> in <span class="citation">[<a href="#ref-rfc2104">3</a>]</span>).</p></li>
</ul>
<p>Noise defines additional functions based on the above <code>HASH()</code> function:</p>
<ul>
<li><p><strong><code>HMAC-HASH(key, data)</code></strong>: Applies <code>HMAC</code> from <span class="citation">[<a href="#ref-rfc2104">3</a>]</span> using the <code>HASH()</code> function. This function is only called as part of <code>HKDF()</code>, below.</p></li>
<li><strong><code>HKDF(chaining_key, input_key_material, num_outputs)</code></strong>: Takes a <code>chaining_key</code> byte sequence of length <code>HASHLEN</code>, and an <code>input_key_material</code> byte sequence with length either zero bytes, 32 bytes, or <code>DHLEN</code> bytes. Returns a pair or triple of byte sequences each of length <code>HASHLEN</code>, depending on whether <code>num_outputs</code> is two or three:
<ul>
<li>Sets <code>temp_key = HMAC-HASH(chaining_key, input_key_material)</code>.</li>
<li>Sets <code>output1 = HMAC-HASH(temp_key, byte(0x01))</code>.</li>
<li>Sets <code>output2 = HMAC-HASH(temp_key, output1 || byte(0x02))</code>.</li>
<li>If <code>num_outputs == 2</code> then returns the pair <code>(output1, output2)</code>.</li>
<li>Sets <code>output3 = HMAC-HASH(temp_key, output2 || byte(0x03))</code>.</li>
<li>Returns the triple <code>(output1, output2, output3)</code>.</li>
</ul></li>
</ul>
<p>Note that <code>temp_key</code>, <code>output1</code>, <code>output2</code>, and <code>output3</code> are all <code>HASHLEN</code> bytes in length. Also note that the <code>HKDF()</code> function is simply <code>HKDF</code> from <span class="citation">[<a href="#ref-rfc5869">4</a>]</span> with the <code>chaining_key</code> as HKDF <code>salt</code>, and zero-length HKDF <code>info</code>.</p>
<h1 id="processing-rules">5. Processing rules</h1>
<p>To precisely define the processing rules we adopt an object-oriented terminology, and present three &quot;objects&quot; which encapsulate state variables and contain functions which implement processing logic. These three objects are presented as a hierarchy: each higher-layer object includes one instance of the object beneath it. From lowest-layer to highest, the objects are:</p>
<ul>
<li><p>A <strong><code>CipherState</code></strong> object contains <code>k</code> and <code>n</code> variables, which it uses to encrypt and decrypt ciphertexts. During the handshake phase each party has a single <code>CipherState</code>, but during the transport phase each party has two <code>CipherState</code> objects: one for sending, and one for receiving.</p></li>
<li><p>A <strong><code>SymmetricState</code></strong> object contains a <code>CipherState</code> plus <code>ck</code> and <code>h</code> variables. It is so-named because it encapsulates all the &quot;symmetric crypto&quot; used by Noise. During the handshake phase each party has a single <code>SymmetricState</code>, which can be deleted once the handshake is finished.</p></li>
<li><p>A <strong><code>HandshakeState</code></strong> object contains a <code>SymmetricState</code> plus DH variables <code>(s, e, rs, re)</code> and a variable representing the handshake pattern. During the handshake phase each party has a single <code>HandshakeState</code>, which can be deleted once the handshake is finished.</p></li>
</ul>
<p>To execute a Noise protocol you <code>Initialize()</code> a <code>HandshakeState</code>. During initialization you specify the handshake pattern, any local key pairs, and any public keys for the remote party you have knowledge of. After <code>Initialize()</code> you call <code>WriteMessage()</code> and <code>ReadMessage()</code> on the <code>HandshakeState</code> to process each handshake message. If any error is signaled by the <code>DECRYPT()</code> or <code>DH()</code> functions then the handshake has failed and the <code>HandshakeState</code> is deleted.</p>
<p>Processing the final handshake message returns two <code>CipherState</code> objects, the first for encrypting transport messages from initiator to responder, and the second for messages in the other direction. At that point the <code>HandshakeState</code> should be deleted except for the hash value <code>h</code>, which may be used for post-handshake channel binding (see <a href="#channel-binding">Section 11.2</a>).</p>
<p>Transport messages are then encrypted and decrypted by calling <code>EncryptWithAd()</code> and <code>DecryptWithAd()</code> on the relevant <code>CipherState</code> with zero-length associated data. If <code>DecryptWithAd()</code> signals an error due to <code>DECRYPT()</code> failure, then the input message is discarded. The application may choose to delete the <code>CipherState</code> and terminate the session on such an error, or may continue to attempt communications. If <code>EncryptWithAd()</code> or <code>DecryptWithAd()</code> signal an error due to nonce exhaustion, then the application must delete the <code>CipherState</code> and terminate the session.</p>
<p>The below sections describe these objects in detail.</p>
<h2 id="the-cipherstate-object">5.1. The <code>CipherState</code> object</h2>
<p>A <code>CipherState</code> can encrypt and decrypt data based on its <code>k</code> and <code>n</code> variables:</p>
<ul>
<li><p><strong><code>k</code></strong>: A cipher key of 32 bytes (which may be <code>empty</code>). <code>Empty</code> is a special value which indicates <code>k</code> has not yet been initialized.</p></li>
<li><p><strong><code>n</code></strong>: An 8-byte (64-bit) unsigned integer nonce.</p></li>
</ul>
<p>A <code>CipherState</code> responds to the following functions. The <code>++</code> post-increment operator applied to <code>n</code> means &quot;use the current <code>n</code> value, then increment it&quot;. The maximum <code>n</code> value (2<sup>64</sup>-1) is reserved for other use. If incrementing <code>n</code> results in 2<sup>64</sup>-1, then any further <code>EncryptWithAd()</code> or <code>DecryptWithAd()</code> calls will signal an error to the caller.</p>
<ul>
<li><p><strong><code>InitializeKey(key)</code></strong>: Sets <code>k = key</code>. Sets <code>n = 0</code>.</p></li>
<li><p><strong><code>HasKey()</code></strong>: Returns true if <code>k</code> is non-empty, false otherwise.</p></li>
<li><p><strong><code>SetNonce(nonce)</code></strong>: Sets <code>n = nonce</code>. This function is used for handling out-of-order transport messages, as described in <a href="#out-of-order-transport-messages">Section 11.4</a>.</p></li>
<li><p><strong><code>EncryptWithAd(ad, plaintext)</code></strong>: If <code>k</code> is non-empty returns <code>ENCRYPT(k, n++, ad, plaintext)</code>. Otherwise returns <code>plaintext</code>.</p></li>
<li><p><strong><code>DecryptWithAd(ad, ciphertext)</code></strong>: If <code>k</code> is non-empty returns <code>DECRYPT(k, n++, ad, ciphertext)</code>. Otherwise returns <code>ciphertext</code>. If an authentication failure occurs in <code>DECRYPT()</code> then <code>n</code> is not incremented and an error is signaled to the caller.</p></li>
<li><p><strong><code>Rekey()</code></strong>: Sets <code>k = REKEY(k)</code>.</p></li>
</ul>
<h2 id="the-symmetricstate-object">5.2. The <code>SymmetricState</code> object</h2>
<p>A <code>SymmetricState</code> object contains a <code>CipherState</code> plus the following variables:</p>
<ul>
<li><strong><code>ck</code></strong>: A chaining key of <code>HASHLEN</code> bytes.</li>
<li><strong><code>h</code></strong>: A hash output of <code>HASHLEN</code> bytes.</li>
</ul>
<p>A <code>SymmetricState</code> responds to the following functions:</p>
<ul>
<li><p><strong><code>InitializeSymmetric(protocol_name)</code></strong>: Takes an arbitrary-length <code>protocol_name</code> byte sequence (see <a href="#protocol-names-and-modifiers">Section 8</a>). Executes the following steps:</p>
<ul>
<li><p>If <code>protocol_name</code> is less than or equal to <code>HASHLEN</code> bytes in length, sets <code>h</code> equal to <code>protocol_name</code> with zero bytes appended to make <code>HASHLEN</code> bytes. Otherwise sets <code>h = HASH(protocol_name)</code>.</p></li>
<li><p>Sets <code>ck = h</code>.</p></li>
<li><p>Calls <code>InitializeKey(empty)</code>.</p></li>
</ul></li>
<li><p><strong><code>MixKey(input_key_material)</code></strong>: Executes the following steps:</p>
<ul>
<li>Sets <code>ck, temp_k = HKDF(ck, input_key_material, 2)</code>.</li>
<li>If <code>HASHLEN</code> is 64, then truncates <code>temp_k</code> to 32 bytes.</li>
<li>Calls <code>InitializeKey(temp_k)</code>.</li>
</ul></li>
<li><p><strong><code>MixHash(data)</code></strong>: Sets <code>h = HASH(h || data)</code>.</p></li>
<li><p><strong><code>MixKeyAndHash(input_key_material)</code></strong>: This function is used for handling pre-shared symmetric keys, as described in <a href="#pre-shared-symmetric-keys">Section 9</a>. It executes the following steps:</p>
<ul>
<li>Sets <code>ck, temp_h, temp_k = HKDF(ck, input_key_material, 3)</code>.</li>
<li>Calls <code>MixHash(temp_h)</code>.</li>
<li>If <code>HASHLEN</code> is 64, then truncates <code>temp_k</code> to 32 bytes.</li>
<li>Calls <code>InitializeKey(temp_k)</code>.</li>
</ul></li>
<li><p><strong><code>GetHandshakeHash()</code></strong>: Returns <code>h</code>. This function should only be called at the end of a handshake, i.e. after the <code>Split()</code> function has been called. This function is used for channel binding, as described in <a href="#channel-binding">Section 11.2</a></p></li>
<li><p><strong><code>EncryptAndHash(plaintext)</code></strong>: Sets <code>ciphertext = EncryptWithAd(h, plaintext)</code>, calls <code>MixHash(ciphertext)</code>, and returns <code>ciphertext</code>. Note that if <code>k</code> is <code>empty</code>, the <code>EncryptWithAd()</code> call will set <code>ciphertext</code> equal to <code>plaintext</code>.</p></li>
<li><p><strong><code>DecryptAndHash(ciphertext)</code></strong>: Sets <code>plaintext = DecryptWithAd(h, ciphertext)</code>, calls <code>MixHash(ciphertext)</code>, and returns <code>plaintext</code>. Note that if <code>k</code> is <code>empty</code>, the <code>DecryptWithAd()</code> call will set <code>plaintext</code> equal to <code>ciphertext</code>.</p></li>
<li><strong><code>Split()</code></strong>: Returns a pair of <code>CipherState</code> objects for encrypting transport messages. Executes the following steps, where <code>zerolen</code> is a zero-length byte sequence:
<ul>
<li>Sets <code>temp_k1, temp_k2 = HKDF(ck, zerolen, 2)</code>.</li>
<li>If <code>HASHLEN</code> is 64, then truncates <code>temp_k1</code> and <code>temp_k2</code> to 32 bytes.</li>
<li>Creates two new <code>CipherState</code> objects <code>c1</code> and <code>c2</code>.</li>
<li>Calls <code>c1.InitializeKey(temp_k1)</code> and <code>c2.InitializeKey(temp_k2)</code>.</li>
<li>Returns the pair <code>(c1, c2)</code>.</li>
</ul></li>
</ul>
<h2 id="the-handshakestate-object">5.3. The <code>HandshakeState</code> object</h2>
<p>A <code>HandshakeState</code> object contains a <code>SymmetricState</code> plus the following variables, any of which may be <code>empty</code>. <code>Empty</code> is a special value which indicates the variable has not yet been initialized.</p>
<ul>
<li><strong><code>s</code></strong>: The local static key pair</li>
<li><strong><code>e</code></strong>: The local ephemeral key pair</li>
<li><strong><code>rs</code></strong>: The remote party's static public key</li>
<li><strong><code>re</code></strong>: The remote party's ephemeral public key</li>
</ul>
<p>A <code>HandshakeState</code> also has variables to track its role, and the remaining portion of the handshake pattern:</p>
<ul>
<li><p><strong><code>initiator</code></strong>: A boolean indicating the initiator or responder role.</p></li>
<li><p><strong><code>message_patterns</code></strong>: A sequence of message patterns. Each message pattern is a sequence of tokens from the set <code>(&quot;e&quot;, &quot;s&quot;, &quot;ee&quot;, &quot;es&quot;, &quot;se&quot;, &quot;ss&quot;)</code>. (An additional <code>&quot;psk&quot;</code> token is introduced in <a href="#pre-shared-symmetric-keys">Section 9</a>, but we defer its explanation until then.)</p></li>
</ul>
<p>A <code>HandshakeState</code> responds to the following functions:</p>
<ul>
<li><p><strong><code>Initialize(handshake_pattern, initiator, prologue, s, e, rs, re)</code></strong>: Takes a valid <code>handshake_pattern</code> (see <a href="#handshake-patterns">Section 7</a>) and an <code>initiator</code> boolean specifying this party's role as either initiator or responder.</p>
<p>Takes a <code>prologue</code> byte sequence which may be zero-length, or which may contain context information that both parties want to confirm is identical (see <a href="#prologue">Section 6</a>).</p>
<p>Takes a set of DH key pairs <code>(s, e)</code> and public keys <code>(rs, re)</code> for initializing local variables, any of which may be empty. Public keys are only passed in if the <code>handshake_pattern</code> uses pre-messages (see <a href="#handshake-patterns">Section 7</a>). The ephemeral values <code>(e, re)</code> are typically left empty, since they are created and exchanged during the handshake; but there are exceptions (see <a href="#compound-patterns">Section 10</a>).</p>
<p>Performs the following steps:</p>
<ul>
<li><p>Derives a <code>protocol_name</code> byte sequence by combining the names for the handshake pattern and crypto functions, as specified in <a href="#protocol-names-and-modifiers">Section 8</a>. Calls <code>InitializeSymmetric(protocol_name)</code>.</p></li>
<li><p>Calls <code>MixHash(prologue)</code>.</p></li>
<li><p>Sets the <code>initiator</code>, <code>s</code>, <code>e</code>, <code>rs</code>, and <code>re</code> variables to the corresponding arguments.</p></li>
<li><p>Calls <code>MixHash()</code> once for each public key listed in the pre-messages from <code>handshake_pattern</code>, with the specified public key as input (see <a href="#handshake-patterns">Section 7</a> for an explanation of pre-messages). If both initiator and responder have pre-messages, the initiator's public keys are hashed first. If multiple public keys are listed in either party's pre-message, the public keys are hashed in the order that they are listed.</p></li>
<li><p>Sets <code>message_patterns</code> to the message patterns from <code>handshake_pattern</code>.</p></li>
</ul></li>
<li><p><strong><code>WriteMessage(payload, message_buffer)</code></strong>: Takes a <code>payload</code> byte sequence which may be zero-length, and a <code>message_buffer</code> to write the output into. Performs the following steps, aborting if any <code>EncryptAndHash()</code> call returns an error:</p>
<ul>
<li><p>Fetches and deletes the next message pattern from <code>message_patterns</code>, then sequentially processes each token from the message pattern:</p>
<ul>
<li><p>For <code>&quot;e&quot;</code>: Sets <code>e</code> (which must be empty) to <code>GENERATE_KEYPAIR()</code>. Appends <code>e.public_key</code> to the buffer. Calls <code>MixHash(e.public_key)</code>.</p></li>
<li><p>For <code>&quot;s&quot;</code>: Appends <code>EncryptAndHash(s.public_key)</code> to the buffer.</p></li>
<li><p>For <code>&quot;ee&quot;</code>: Calls <code>MixKey(DH(e, re))</code>.</p></li>
<li><p>For <code>&quot;es&quot;</code>: Calls <code>MixKey(DH(e, rs))</code> if initiator, <code>MixKey(DH(s, re))</code> if responder.</p></li>
<li><p>For <code>&quot;se&quot;</code>: Calls <code>MixKey(DH(s, re))</code> if initiator, <code>MixKey(DH(e, rs))</code> if responder.</p></li>
<li><p>For <code>&quot;ss&quot;</code>: Calls <code>MixKey(DH(s, rs))</code>.</p></li>
</ul></li>
<li><p>Appends <code>EncryptAndHash(payload)</code> to the buffer.</p></li>
<li><p>If there are no more message patterns returns two new <code>CipherState</code> objects by calling <code>Split()</code>.</p></li>
</ul></li>
</ul>

<ul>
<li><p><strong><code>ReadMessage(message, payload_buffer)</code></strong>: Takes a byte sequence containing a Noise handshake message, and a <code>payload_buffer</code> to write the message's plaintext payload into. Performs the following steps, aborting if any <code>DecryptAndHash()</code> call returns an error:</p>
<ul>
<li><p>Fetches and deletes the next message pattern from <code>message_patterns</code>, then sequentially processes each token from the message pattern:</p>
<ul>
<li><p>For <code>&quot;e&quot;</code>: Sets <code>re</code> (which must be empty) to the next <code>DHLEN</code> bytes from the message. Calls <code>MixHash(re.public_key)</code>.</p></li>
<li><p>For <code>&quot;s&quot;</code>: Sets <code>temp</code> to the next <code>DHLEN + 16</code> bytes of the message if <code>HasKey() == True</code>, or to the next <code>DHLEN</code> bytes otherwise. Sets <code>rs</code> (which must be empty) to <code>DecryptAndHash(temp)</code>.</p></li>
<li><p>For <code>&quot;ee&quot;</code>: Calls <code>MixKey(DH(e, re))</code>.</p></li>
<li><p>For <code>&quot;es&quot;</code>: Calls <code>MixKey(DH(e, rs))</code> if initiator, <code>MixKey(DH(s, re))</code> if responder.</p></li>
<li><p>For <code>&quot;se&quot;</code>: Calls <code>MixKey(DH(s, re))</code> if initiator, <code>MixKey(DH(e, rs))</code> if responder.</p></li>
<li><p>For <code>&quot;ss&quot;</code>: Calls <code>MixKey(DH(s, rs))</code>.</p></li>
</ul></li>
<li><p>Calls <code>DecryptAndHash()</code> on the remaining bytes of the message and stores the output into <code>payload_buffer</code>.</p></li>
<li><p>If there are no more message patterns returns two new <code>CipherState</code> objects by calling <code>Split()</code>.</p></li>
</ul></li>
</ul>
<h1 id="prologue">6. Prologue</h1>
<p>Noise protocols have a <strong>prologue</strong> input which allows arbitrary data to be hashed into the <code>h</code> variable. If both parties do not provide identical prologue data, the handshake will fail due to a decryption error. This is useful when the parties engaged in negotiation prior to the handshake and want to ensure they share identical views of that negotiation.</p>
<p>For example, suppose Bob communicates to Alice a list of Noise protocols that he is willing to support. Alice will then choose and execute a single protocol. To ensure that a &quot;man-in-the-middle&quot; did not edit Bob's list to remove options, Alice and Bob could include the list as prologue data.</p>
<p>Note that while the parties confirm their prologues are identical, they don't mix prologue data into encryption keys. If an input contains secret data that’s intended to strengthen the encryption, a PSK handshake should be used instead (see <a href="pre-shared-symmetric-keys">Section 9</a>).</p>
<h1 id="handshake-patterns">7. Handshake patterns</h1>
<h2 id="handshake-pattern-basics">7.1. Handshake pattern basics</h2>
<p>A <strong>message pattern</strong> is some sequence of tokens from the set <code>(&quot;e&quot;, &quot;s&quot;, &quot;ee&quot;, &quot;es&quot;, &quot;se&quot;, &quot;ss&quot;, &quot;psk&quot;)</code>. The handling of these tokens within <code>WriteMessage()</code> and <code>ReadMessage()</code> has been described previously, except for the <code>&quot;psk&quot;</code> token, which will be described in <a href="pre-shared-symmetric-keys">Section 9</a>. Future specifications might introduce other tokens.</p>
<p>A <strong>pre-message pattern</strong> is one of the following sequences of tokens:</p>
<ul>
<li><code>&quot;e&quot;</code></li>
<li><code>&quot;s&quot;</code></li>
<li><code>&quot;e, s&quot;</code></li>
<li>empty</li>
</ul>
<p>A <strong>handshake pattern</strong> consists of:</p>
<ul>
<li><p>A pre-message pattern for the initiator, representing information about the initiator's public keys that is known to the responder.</p></li>
<li><p>A pre-message pattern for the responder, representing information about the responder's public keys that is known to the initiator.</p></li>
<li><p>A sequence of message patterns for the actual handshake messages.</p></li>
</ul>
<p>The pre-messages represent an exchange of public keys that was somehow performed prior to the handshake, so these public keys must be inputs to <code>Initialize()</code> for the &quot;recipient&quot; of the pre-message.</p>
<p>The first actual handshake message is sent from the initiator to the responder. The next message is sent from the responder, the next from the initiator, and so on in alternating fashion.</p>
<p>The following handshake pattern describes an unauthenticated DH handshake consisting of two message patterns:</p>
<pre><code>NN:
  -&gt; e
  &lt;- e, ee</code></pre>
<p>In the following handshake pattern both the initiator and responder possess static key pairs, and the handshake pattern comprises three message patterns:</p>
<pre><code>XX:
  -&gt; e
  &lt;- e, ee, s, es
  -&gt; s, se</code></pre>
<p>The handshake pattern names are <code>NN</code> and <code>XX</code>. This naming convention will be explained in <a href="#interactive-handshake-patterns-fundamental">Section 7.5</a>.</p>
<p>Non-empty pre-messages are shown as pre-message patterns prior to the delimiter <code>&quot;...&quot;</code>. If both parties have a pre-message, the initiator's is listed first, and hashed first. During <code>Initialize()</code>, <code>MixHash()</code> is called on any pre-message public keys, as described in <a href="#the-handshakestate-object">Section 5.3</a>.</p>
<p>The following handshake pattern describes a handshake where the initiator has pre-knowledge of the responder's static public key and uses it for &quot;zero-RTT&quot; encryption:</p>
<pre><code>NK:
  &lt;- s
  ...
  -&gt; e, es 
  &lt;- e, ee</code></pre>
<p>In the following handshake pattern both parties have pre-knowledge of the other's static public key. The initiator's pre-message is listed first:</p>
<pre><code>KK:
  -&gt; s
  &lt;- s
  ...
  -&gt; e, es, ss
  &lt;- e, ee, se</code></pre>

<h2 id="alice-and-bob">7.2. Alice and Bob</h2>
<p>In all handshake patterns shown previously, the initiator is the party on the left (sending with right-pointing arrows) and the responder is the party on the right.</p>
<p>However, multiple Noise protocols might be used within a <strong>compound protocol</strong> where the responder in one Noise protocol becomes the initiator for a later Noise protocol. As a convenience for terminology and notation in this case, we introduce the notion of <strong>Alice</strong> and <strong>Bob</strong> roles which are different from initiator and responder roles. Alice will be viewed as the party on the left (sending messages with right arrows), and Bob will be the party on the right.</p>
<p>Handshake patterns written in <strong>canonical form</strong> (i.e. <strong>Alice-initiated form</strong>) assume the initiator is Alice (the left-most party). All processing rules and discussion so far have assumed canonical-form handshake patterns.</p>
<p>However, handshake patterns can be written in <strong>Bob-initiated form</strong> by reversing the arrows and the DH tokens (e.g. replacing <code>&quot;es&quot;</code> with <code>&quot;se&quot;</code>, and vice versa). This doesn't change the handshake pattern, it simply makes it easier to view Alice-initiated and Bob-initiated handshakes side-by-side.</p>
<p>Below are the handshake patterns from the previous section in Bob-initiated form:</p>
<pre><code>NN:
  &lt;- e
  -&gt; e, ee

XX:
  &lt;- e
  -&gt; e, ee, s, se
  &lt;- s, es

NK:
  -&gt; s
  ...
  &lt;- e, se
  -&gt; e, ee

KK:
  &lt;- s
  -&gt; s
  ...
  &lt;- e, se, ss
  -&gt; e, ee, es</code></pre>
<p>For an example of Bob-initiated notation, see <a href="#the-fallback-modifier">Section 10.2</a>.</p>
<h2 id="handshake-pattern-validity">7.3. Handshake pattern validity</h2>
<p>Handshake patterns must be <strong>valid</strong> in the following senses:</p>
<ol style="list-style-type: decimal">
<li><p>Parties can only perform DH between private keys and public keys they possess.</p></li>
<li><p>Parties must not send their static public key or ephemeral public key more than once per handshake (i.e. including the pre-messages, there must be no more than one occurrence of <code>&quot;e&quot;</code>, and one occurrence of <code>&quot;s&quot;</code>, in the messages sent by any party).</p></li>
<li><p>Parties must not perform a DH calculation more than once per handshake (i.e. there must be no more than one occurrence of <code>&quot;ee&quot;</code>, <code>&quot;es&quot;</code>, <code>&quot;se&quot;</code>, or <code>&quot;ss&quot;</code> per handshake).</p></li>
<li><p>After performing a DH between a remote public key (either static or ephemeral) and the local static key, the local party must not call <code>ENCRYPT()</code> unless it has also performed a DH between its local ephemeral key and the remote public key. In particular, this means that (using canonical notation):</p>
<p>After an <code>&quot;se&quot;</code> token, the initiator must not send a handshake payload or transport payload unless there has also been an <code>&quot;ee&quot;</code> token.</p>
<p>After an <code>&quot;ss&quot;</code> token, the initiator must not send a handshake payload or transport payload unless there has also been an <code>&quot;es&quot;</code> token.</p>
<p>After an <code>&quot;es&quot;</code> token, the responder must not send a handshake payload or transport payload unless there has also been an <code>&quot;ee&quot;</code> token.</p>
<p>After an <code>&quot;ss&quot;</code> token, the responder must not send a handshake payload or transport payload unless there has also been an <code>&quot;se&quot;</code> token.</p></li>
</ol>
<p>Patterns failing the first check are obviously nonsense.</p>
<p>The second and third checks outlaw redundant transmission of values, and redundant computation, to simplify implementation and testing.</p>
<p>The fourth check accomplishes two purposes:</p>
<ul>
<li><p>First, it is necessary because Noise relies on DH outputs involving ephemeral keys to randomize the shared secret keys. Patterns failing this check could result in catastrophic key reuse, because the victim might send a message encrypted with a key that doesn't include a contribution from their local ephemeral key (or where the contribution from their local ephemeral was nullified by an invalid ephemeral from the other party).</p></li>
<li><p>Second, this check guarantees that ephemeral keys are used to provide important security properties such as forward-secrecy and key-compromise impersonation resistance.</p></li>
</ul>
<p>Users are recommended to only use the handshake patterns listed below, or other patterns that have been vetted by experts to satisfy the above checks.</p>
<h2 id="one-way-handshake-patterns">7.4. One-way handshake patterns</h2>
<p>The following handshake patterns represent &quot;one-way&quot; handshakes supporting a one-way stream of data from a sender to a recipient. These patterns could be used to encrypt files, database records, or other non-interactive data streams.</p>
<p>Following a one-way handshake the sender can send a stream of transport messages, encrypting them using the first <code>CipherState</code> returned by <code>Split()</code>. The second <code>CipherState</code> from <code>Split()</code> is discarded - the recipient must not send any messages using it (as this would violate the rules in <a href="#handshake-pattern-validity">Section 7.3</a>).</p>
<p>One-way patterns are named with a single character, which indicates the status of the sender's static key:</p>
<ul>
<li><strong><code>N</code></strong> = <strong><code>N</code></strong>o static key for sender</li>
<li><strong><code>K</code></strong> = Static key for sender <strong><code>K</code></strong>nown to recipient</li>
<li><strong><code>X</code></strong> = Static key for sender <strong><code>X</code></strong>mitted (&quot;transmitted&quot;) to recipient</li>
</ul>
<table style="width:36%;">
<colgroup>
<col width="36%" />
</colgroup>
<tbody>
<tr class="odd">
<td><pre><code>N:
  &lt;- s
  ...
  -&gt; e, es</code></pre></td>
</tr>
<tr class="even">
<td><pre><code>K:
  -&gt; s
  &lt;- s
  ...
  -&gt; e, es, ss</code></pre></td>
</tr>
<tr class="odd">
<td><pre><code>X:
  &lt;- s
  ...
  -&gt; e, es, s, ss</code></pre></td>
</tr>
</tbody>
</table>
<p><code>N</code> is a conventional DH-based public-key encryption. The other patterns add sender authentication, where the sender's public key is either known to the recipient beforehand (<code>K</code>) or transmitted under encryption (<code>X</code>).</p>

<h2 id="interactive-handshake-patterns-fundamental">7.5. Interactive handshake patterns (fundamental)</h2>
<p>The following handshake patterns represent interactive protocols. These 12 patterns are called the <strong>fundamental</strong> interactive handshake patterns.</p>
<p>The fundamental interactive patterns are named with two characters, which indicate the status of the initiator and responder's static keys:</p>
<p>The first character refers to the initiator's static key:</p>
<ul>
<li><strong><code>N</code></strong> = <strong><code>N</code></strong>o static key for initiator</li>
<li><strong><code>K</code></strong> = Static key for initiator <strong><code>K</code></strong>nown to responder</li>
<li><strong><code>X</code></strong> = Static key for initiator <strong><code>X</code></strong>mitted (&quot;transmitted&quot;) to responder</li>
<li><strong><code>I</code></strong> = Static key for initiator <strong><code>I</code></strong>mmediately transmitted to responder, despite reduced or absent identity hiding</li>
</ul>
<p>The second character refers to the responder's static key:</p>
<ul>
<li><strong><code>N</code></strong> = <strong><code>N</code></strong>o static key for responder</li>
<li><strong><code>K</code></strong> = Static key for responder <strong><code>K</code></strong>nown to initiator</li>
<li><strong><code>X</code></strong> = Static key for responder <strong><code>X</code></strong>mitted (&quot;transmitted&quot;) to initiator</li>
</ul>

<table style="width:85%;">
<colgroup>
<col width="38%" />
<col width="45%" />
</colgroup>
<tbody>
<tr class="odd">
<td><pre><code>NN:
  -&gt; e
  &lt;- e, ee</code></pre></td>
<td><pre><code>   KN:
     -&gt; s
     ...
     -&gt; e
     &lt;- e, ee, se</code></pre></td>
</tr>
<tr class="even">
<td><pre><code>NK:
  &lt;- s
  ...
  -&gt; e, es
  &lt;- e, ee</code></pre></td>
<td><pre><code>   KK:
     -&gt; s
     &lt;- s
     ...
     -&gt; e, es, ss
     &lt;- e, ee, se</code></pre></td>
</tr>
<tr class="odd">
<td><pre><code>NX:
  -&gt; e
  &lt;- e, ee, s, es</code></pre></td>
<td><pre><code>    KX:
      -&gt; s
      ...
      -&gt; e
      &lt;- e, ee, se, s, es</code></pre></td>
</tr>
<tr class="even">
<td><pre><code>XN:
  -&gt; e
  &lt;- e, ee
  -&gt; s, se</code></pre></td>
<td><pre><code>    IN:
      -&gt; e, s
      &lt;- e, ee, se</code></pre></td>
</tr>
<tr class="odd">
<td><pre><code>XK:
  &lt;- s
  ...
  -&gt; e, es
  &lt;- e, ee
  -&gt; s, se</code></pre></td>
<td><pre><code>    IK:
      &lt;- s
      ...
      -&gt; e, es, s, ss
      &lt;- e, ee, se</code></pre></td>
</tr>
<tr class="even">
<td><pre><code>XX:
  -&gt; e
  &lt;- e, ee, s, es
  -&gt; s, se</code></pre></td>
<td><pre><code>    IX:
      -&gt; e, s
      &lt;- e, ee, se, s, es</code></pre></td>
</tr>
</tbody>
</table>

<p>The <code>XX</code> pattern is the most generically useful, since it supports mutual authentication and transmission of static public keys.</p>
<p>All fundamental patterns allow some encryption of handshake payloads:</p>
<ul>
<li><p>Patterns where the initiator has pre-knowledge of the responder's static public key (i.e. patterns ending in <code>K</code>) allow <strong>zero-RTT</strong> encryption, meaning the initiator can encrypt the first handshake payload.</p></li>
<li><p>All fundamental patterns allow <strong>half-RTT</strong> encryption of the first response payload, but the encryption only targets an initiator static public key in patterns starting with <code>K</code> or <code>I</code>.</p></li>
</ul>
<p>The security properties for handshake payloads are usually weaker than the final security properties achieved by transport payloads, so these early encryptions must be used with caution.</p>
<p>In some patterns the security properties of transport payloads can also vary. In particular: patterns starting with <code>K</code> or <code>I</code> have the caveat that the responder is only guaranteed &quot;weak&quot; forward secrecy for the transport messages it sends until it receives a transport message from the initiator. After receiving a transport message from the initiator, the responder becomes assured of &quot;strong&quot; forward secrecy.</p>
<p>More analysis of these payload security properties is in <a href="#payload-security-properties">Section 7.7</a>.</p>
<h2 id="interactive-handshake-patterns-deferred">7.6. Interactive handshake patterns (deferred)</h2>
<p>The fundamental handshake patterns in the previous section perform DH operations for authentication (<code>&quot;es&quot;</code> and <code>&quot;se&quot;</code>) as early as possible.</p>
<p>An additional set of handshake patterns can be described which defer these authentication DHs to the next message. To name these <strong>deferred handshake patterns</strong>, the numeral &quot;1&quot; is used after the first and/or second character in a fundamental pattern name to indicate that the initiator and/or responder's authentication DH is deferred to the next message.</p>
<p>Deferred patterns might be useful for several reasons:</p>
<ul>
<li><p>The initiator might have prior knowledge of the responder's static public key, but not wish to send any 0-RTT encrypted data.</p></li>
<li><p>In some cases, deferring authentication can improve the identity-hiding properties of the handshake (see <a href="#identity-hiding">Section 7.8</a>).</p></li>
<li><p>Future extensions to Noise might be capable of replacing DH operations with signatures or KEM ciphertexts, but would only be able to do so if the sender is authenticating themselves (signatures) or the sender is authenticating the recipient (KEM ciphertexts). Thus every fundamental handshake pattern is only capable of having each authentication DH replaced with a signature <em>or</em> KEM ciphertext, but the deferred variants make both replacements possible.</p></li>
</ul>
<p>Below are two examples showing a fundamental handshake pattern on the left, and deferred variant(s) on the right. The full set of 23 deferred handshake patterns are in the <a href="#deferred-patterns">Appendix</a>.</p>
<table style="width:85%;">
<colgroup>
<col width="38%" />
<col width="45%" />
</colgroup>
<tbody>
<tr class="odd">
<td><pre><code>NK:
  &lt;- s
  ...
  -&gt; e, es
  &lt;- e, ee</code></pre></td>
<td><pre><code>    NK1:
      &lt;- s
      ...
      -&gt; e
      &lt;- e, ee, es</code></pre></td>
</tr>
<tr class="even">
<td><pre><code>XX:
  -&gt; e
  &lt;- e, ee, s, es
  -&gt; s, se</code></pre></td>
<td><pre><code>    X1X:
      -&gt; e
      &lt;- e, ee, s, es
      -&gt; s
      &lt;- se

    XX1:
      -&gt; e
      &lt;- e, ee, s
      -&gt; es, s, se

    X1X1:
      -&gt; e
      &lt;- e, ee, s
      -&gt; es, s
      &lt;- se</code></pre></td>
</tr>
</tbody>
</table>
<h2 id="payload-security-properties">7.7. Payload security properties</h2>
<p>The following table lists the security properties for Noise handshake and transport payloads for all the one-way patterns in <a href="#one-way-handshake-patterns">Section 7.4</a> and the fundamental patterns in <a href="#interactive-handshake-patterns-fundamental">Section 7.5</a>. Each payload is assigned a &quot;source&quot; property regarding the degree of authentication of the sender provided to the recipient, and a &quot;destination&quot; property regarding the degree of confidentiality provided to the sender.</p>
<p>The source properties are:</p>
<ol start="0" style="list-style-type: decimal">
<li><p><strong>No authentication.</strong> This payload may have been sent by any party, including an active attacker.</p></li>
<li><p><strong>Sender authentication <em>vulnerable</em> to key-compromise impersonation (KCI)</strong>. The sender authentication is based on a static-static DH (<code>&quot;ss&quot;</code>) involving both parties' static key pairs. If the recipient's long-term private key has been compromised, this authentication can be forged. Note that a future version of Noise might include signatures, which could improve this security property, but brings other trade-offs.</p></li>
<li><p><strong>Sender authentication <em>resistant</em> to key-compromise impersonation (KCI)</strong>. The sender authentication is based on an ephemeral-static DH (<code>&quot;es&quot;</code> or <code>&quot;se&quot;</code>) between the sender's static key pair and the recipient's ephemeral key pair. Assuming the corresponding private keys are secure, this authentication cannot be forged.</p></li>
</ol>
<p>The destination properties are:</p>
<ol start="0" style="list-style-type: decimal">
<li><p><strong>No confidentiality.</strong> This payload is sent in cleartext.</p></li>
<li><p><strong>Encryption to an ephemeral recipient.</strong> This payload has forward secrecy, since encryption involves an ephemeral-ephemeral DH (<code>&quot;ee&quot;</code>). However, the sender has not authenticated the recipient, so this payload might be sent to any party, including an active attacker.</p></li>
<li><p><strong>Encryption to a known recipient, forward secrecy for sender compromise only, vulnerable to replay.</strong> This payload is encrypted based only on DHs involving the recipient's static key pair. If the recipient's static private key is compromised, even at a later date, this payload can be decrypted. This message can also be replayed, since there's no ephemeral contribution from the recipient.</p></li>
<li><p><strong>Encryption to a known recipient, weak forward secrecy.</strong> This payload is encrypted based on an ephemeral-ephemeral DH and also an ephemeral-static DH involving the recipient's static key pair. However, the binding between the recipient's alleged ephemeral public key and the recipient's static public key hasn't been verified by the sender, so the recipient's alleged ephemeral public key may have been forged by an active attacker. In this case, the attacker could later compromise the recipient's static private key to decrypt the payload. Note that a future version of Noise might include signatures, which could improve this security property, but brings other trade-offs.</p></li>
<li><p><strong>Encryption to a known recipient, weak forward secrecy if the sender's private key has been compromised.</strong> This payload is encrypted based on an ephemeral-ephemeral DH, and also based on an ephemeral-static DH involving the recipient's static key pair. However, the binding between the recipient's alleged ephemeral public and the recipient's static public key has only been verified based on DHs involving both those public keys and the sender's static private key. Thus, if the sender's static private key was previously compromised, the recipient's alleged ephemeral public key may have been forged by an active attacker. In this case, the attacker could later compromise the intended recipient's static private key to decrypt the payload (this is a variant of a &quot;KCI&quot; attack enabling a &quot;weak forward secrecy&quot; attack). Note that a future version of Noise might include signatures, which could improve this security property, but brings other trade-offs.</p></li>
<li><p><strong>Encryption to a known recipient, strong forward secrecy.</strong> This payload is encrypted based on an ephemeral-ephemeral DH as well as an ephemeral-static DH with the recipient's static key pair. Assuming the ephemeral private keys are secure, and the recipient is not being actively impersonated by an attacker that has stolen its static private key, this payload cannot be decrypted.</p></li>
</ol>
<p>For one-way handshakes, the below-listed security properties apply to the handshake payload as well as transport payloads.</p>
<p>For interactive handshakes, security properties are listed for each handshake payload. Transport payloads are listed as arrows without a pattern. Transport payloads are only listed if they have different security properties than the previous handshake payload sent from the same party. If two transport payloads are listed, the security properties for the second only apply if the first was received.</p>
<table style="width:88%;">
<colgroup>
<col width="87%" />
</colgroup>
<tbody>
<tr class="odd">
<td><pre><code>                         Source         Destination</code></pre></td>
</tr>
<tr class="even">
<td><pre><code>N                           0                2</code></pre></td>
</tr>
<tr class="odd">
<td><pre><code>K                           1                2</code></pre></td>
</tr>
<tr class="even">
<td><pre><code>X                           1                2</code></pre></td>
</tr>
<tr class="odd">
<td><pre><code>NN
  -&gt; e                      0                0
  &lt;- e, ee                  0                1
  -&gt;                        0                1</code></pre></td>
</tr>
<tr class="even">
<td><pre><code>NK
  &lt;- s
  ...
  -&gt; e, es                  0                2
  &lt;- e, ee                  2                1
  -&gt;                        0                5</code></pre></td>
</tr>
<tr class="odd">
<td><pre><code>NX
  -&gt; e                      0                0
  &lt;- e, ee, s, es           2                1
  -&gt;                        0                5</code></pre></td>
</tr>
<tr class="even">
<td><pre><code>XN
  -&gt; e                      0                0
  &lt;- e, ee                  0                1
  -&gt; s, se                  2                1
  &lt;-                        0                5</code></pre></td>
</tr>
<tr class="odd">
<td><pre><code>XK
  &lt;- s
  ...
  -&gt; e, es                  0                2
  &lt;- e, ee                  2                1
  -&gt; s, se                  2                5
  &lt;-                        2                5</code></pre></td>
</tr>
<tr class="even">
<td><pre><code>XX
  -&gt; e                      0                0
  &lt;- e, ee, s, es           2                1
  -&gt; s, se                  2                5
  &lt;-                        2                5</code></pre></td>
</tr>
<tr class="odd">
<td><pre><code>KN
  -&gt; s
  ...
  -&gt; e                      0                0
  &lt;- e, ee, se              0                3
  -&gt;                        2                1
  &lt;-                        0                5</code></pre></td>
</tr>
<tr class="even">
<td><pre><code>KK
  -&gt; s
  &lt;- s
  ...
  -&gt; e, es, ss              1                2
  &lt;- e, ee, se              2                4
  -&gt;                        2                5
  &lt;-                        2                5</code></pre></td>
</tr>
<tr class="odd">
<td><pre><code>KX
  -&gt; s
  ...
  -&gt; e                      0                0
  &lt;- e, ee, se, s, es       2                3
  -&gt;                        2                5
  &lt;-                        2                5</code></pre></td>
</tr>
<tr class="even">
<td><pre><code>IN
  -&gt; e, s                   0                0
  &lt;- e, ee, se              0                3
  -&gt;                        2                1
  &lt;-                        0                5</code></pre></td>
</tr>
<tr class="odd">
<td><pre><code>IK
  &lt;- s
  ...
  -&gt; e, es, s, ss           1                2
  &lt;- e, ee, se              2                4
  -&gt;                        2                5
  &lt;-                        2                5</code></pre></td>
</tr>
<tr class="even">
<td><pre><code>IX
  -&gt; e, s                   0                0
  &lt;- e, ee, se, s, es       2                3
  -&gt;                        2                5
  &lt;-                        2                5</code></pre></td>
</tr>
</tbody>
</table>
<h2 id="identity-hiding">7.8. Identity hiding</h2>
<p>The following table lists the identity-hiding properties for all the one-way handshake patterns in <a href="#one-way-handshake-patterns">Section 7.4</a> and the fundamental handshake patterns in <a href="#interactive-handshake-patterns-fundamental">Section 7.5</a>. In addition, we list a few deferred handshake patterns which have different identity-hiding properties than the corresponding fundamental pattern.</p>
<p>Each pattern is assigned properties describing the confidentiality supplied to the initiator's static public key, and to the responder's static public key. The underlying assumptions are that ephemeral private keys are secure, and that parties abort the handshake if they receive a static public key from the other party which they don't trust.</p>
<p>This section only considers identity leakage through static public key fields in handshakes. Of course, the identities of Noise participants might be exposed through other means, including payload fields, traffic analysis, or metadata such as IP addresses.</p>
<p>The properties for the relevant public key are:</p>
<ol start="0" style="list-style-type: decimal">
<li><p>Transmitted in clear.</p></li>
<li><p>Encrypted with forward secrecy, but can be probed by an anonymous initiator.</p></li>
<li><p>Encrypted with forward secrecy, but sent to an anonymous responder.</p></li>
<li><p>Not transmitted, but a passive attacker can check candidates for the responder's private key and determine whether the candidate is correct. An attacker could also replay a previously-recorded message to a new responder and determine whether the two responders are the &quot;same&quot; (i.e. are using the same static key pair) by whether the recipient accepts the message.</p></li>
<li><p>Encrypted to responder's static public key, without forward secrecy. If an attacker learns the responder's private key they can decrypt the initiator's public key.</p></li>
<li><p>Not transmitted, but a passive attacker can check candidates for the pair of (responder's private key, initiator's public key) and learn whether the candidate pair is correct.</p></li>
<li><p>Encrypted but with weak forward secrecy. An active attacker who pretends to be the initiator without the initiator's static private key, then later learns the initiator private key, can then decrypt the responder's public key.</p></li>
<li><p>Not transmitted, but an active attacker who pretends to be the initator without the initiator's static private key, then later learns a candidate for the initiator private key, can then check whether the candidate is correct.</p></li>
<li><p>Encrypted with forward secrecy to an authenticated party.</p></li>
<li><p>An active attacker who pretends to be the initiator and records a single protocol run can then check candidates for the responder's public key.</p></li>
</ol>
<!-- end of list - necesary to trick Markdown into seeing the following -->
<table style="width:60%;">
<colgroup>
<col width="59%" />
</colgroup>
<tbody>
<tr class="odd">
<td><pre><code>           Initiator      Responder</code></pre></td>
</tr>
<tr class="even">
<td><pre><code>N              -              3</code></pre></td>
</tr>
<tr class="odd">
<td><pre><code>K              5              5</code></pre></td>
</tr>
<tr class="even">
<td><pre><code>X              4              3</code></pre></td>
</tr>
<tr class="odd">
<td><pre><code>NN             -              -</code></pre></td>
</tr>
<tr class="even">
<td><pre><code>NK             -              3</code></pre></td>
</tr>
<tr class="odd">
<td><pre><code>NK1            -              9</code></pre></td>
</tr>
<tr class="even">
<td><pre><code>NX             -              1</code></pre></td>
</tr>
<tr class="odd">
<td><pre><code>XN             2              -</code></pre></td>
</tr>
<tr class="even">
<td><pre><code>XK             8              3</code></pre></td>
</tr>
<tr class="odd">
<td><pre><code>XK1            8              9</code></pre></td>
</tr>
<tr class="even">
<td><pre><code>XX             8              1</code></pre></td>
</tr>
<tr class="odd">
<td><pre><code>KN             7              -</code></pre></td>
</tr>
<tr class="even">
<td><pre><code>KK             5              5</code></pre></td>
</tr>
<tr class="odd">
<td><pre><code>KX             7              6</code></pre></td>
</tr>
<tr class="even">
<td><pre><code>IN             0              -</code></pre></td>
</tr>
<tr class="odd">
<td><pre><code>IK             4              3</code></pre></td>
</tr>
<tr class="even">
<td><pre><code>IK1            0              9</code></pre></td>
</tr>
<tr class="odd">
<td><pre><code>IX             0              6</code></pre></td>
</tr>
</tbody>
</table>

<h1 id="protocol-names-and-modifiers">8. Protocol names and modifiers</h1>
<p>To produce a <strong>Noise protocol name</strong> for <code>Initialize()</code> you concatenate the ASCII string <code>&quot;Noise_&quot;</code> with four underscore-separated name sections which sequentially name the handshake pattern, the DH functions, the cipher functions, and then the hash functions. The resulting name must be 255 bytes or less. Examples:</p>
<ul>
<li><code>Noise_XX_25519_AESGCM_SHA256</code></li>
<li><code>Noise_N_25519_ChaChaPoly_BLAKE2s</code></li>
<li><code>Noise_IK_448_ChaChaPoly_BLAKE2b</code></li>
</ul>
<p>Each name section must consist only of alphanumeric characters (i.e. characters in one of the ranges <code>&quot;A&quot;</code>...<code>&quot;Z&quot;</code>, <code>&quot;a&quot;</code>...<code>&quot;z&quot;</code>, and <code>&quot;0&quot;</code>...<code>&quot;9&quot;</code>), and the two special characters <code>&quot;+&quot;</code> and <code>&quot;/&quot;</code>.</p>
<p>Additional rules apply to each name section, as specified below.</p>
<h2 id="handshake-pattern-name-section">8.1. Handshake pattern name section</h2>
<p>A handshake pattern name section contains a handshake pattern name plus a sequence of zero or more <strong>pattern modifiers</strong>.</p>
<p>The handshake pattern name must be an uppercase ASCII string containing only alphabetic characters or numerals (e.g. <code>&quot;XX1&quot;</code> or <code>&quot;IK&quot;</code>).</p>
<p>Pattern modifiers specify arbitrary extensions or modifications to the behavior specified by the handshake pattern. For example, a modifier could be applied to a handshake pattern which transforms it into a different pattern according to some rule. The <code>&quot;psk0&quot;</code> and <code>&quot;fallback&quot;</code> modifiers are examples of this, and will be defined later in this document.</p>
<p>A pattern modifier is named with a lowercase alphanumeric ASCII string which must begin with an alphabetic character (not a numeral). The pattern modifier is appended to the base pattern as described below:</p>
<p>The first modifier added onto a base pattern is simply appended. Thus the <code>&quot;fallback&quot;</code> modifier, when added to the <code>&quot;XX&quot;</code> pattern, produces <code>&quot;XXfallback&quot;</code>. Additional modifiers are separated with a plus sign. Thus, adding the <code>&quot;psk0&quot;</code> modifier would result in the name section <code>&quot;XXfallback+psk0&quot;</code>, or a full protocol name such as <code>&quot;Noise_XXfallback+psk0_25519_AESGCM_SHA256&quot;</code>.</p>
<p>In some cases the sequential ordering of modifiers will specify different protocols. However, if the order of some modifiers does not matter, then they are required to be sorted alphabetically (this is an arbitrary convention to ensure interoperability).</p>
<h2 id="cryptographic-algorithm-name-sections">8.2. Cryptographic algorithm name sections</h2>
<p>The rules for the DH, cipher, and hash name sections are identical. Each name section must contain one or more algorithm names separated by plus signs.</p>
<p>Each algorithm name must consist solely of alphanumeric characters and the forward-slash character (<code>&quot;/&quot;</code>). Algorithm names are recommended to be short, and to use the <code>&quot;/&quot;</code> character only when necessary to avoid ambiguity (e.g. <code>&quot;SHA3/256&quot;</code> is preferable to <code>&quot;SHA3256&quot;</code>).</p>
<p>In most cases there will be a single algorithm name in each name section (i.e. no plus signs). Multiple algorithm names are only used when called for by the pattern or a modifier.</p>
<p>None of the patterns or modifiers in this document require multiple algorithm names in any name section. However, this functionality might be useful in future extensions. For example, multiple algorithm names might be used in the DH section to specify &quot;hybrid&quot; post-quantum forward secrecy; or multiple hash algorithms might be specified for different purposes.</p>
<h1 id="pre-shared-symmetric-keys">9. Pre-shared symmetric keys</h1>
<p>Noise provides a <strong>pre-shared symmetric key</strong> or <strong>PSK</strong> mode to support protocols where both parties have a 32-byte shared secret key.</p>
<h2 id="cryptographic-functions">9.1. Cryptographic functions</h2>
<p>PSK mode uses the <code>SymmetricState.MixKeyAndHash()</code> function to mix the PSK into both the encryption keys and the <code>h</code> value.</p>
<p>Note that <code>MixKeyAndHash()</code> uses <code>HKDF(..., 3)</code>. The third output from <code>HKDF()</code> is used as the <code>k</code> value so that calculation of <code>k</code> may be skipped if <code>k</code> is not used.</p>
<h2 id="handshake-tokens">9.2. Handshake tokens</h2>
<p>In a PSK handshake, a <code>&quot;psk&quot;</code> token is allowed to appear one or more times in a handshake pattern. This token can only appear in message patterns (not pre-message patterns). This token is processed by calling <code>MixKeyAndHash(psk)</code>, where <code>psk</code> is a 32-byte secret value provided by the application.</p>
<p>In non-PSK handshakes, the <code>&quot;e&quot;</code> token in a pre-message pattern or message pattern always results in a call to <code>MixHash(e.public_key)</code>. In a PSK handshake, all of these calls are followed by <code>MixKey(e.public_key)</code>. In conjunction with the validity rule in the next section, this ensures that PSK-based encryption uses encryption keys that are randomized using ephemeral public keys as nonces.</p>
<h2 id="validity-rule">9.3. Validity rule</h2>
<p>To prevent catastrophic key reuse, handshake patterns using the <code>&quot;psk&quot;</code> token must follow an additional validity rule:</p>
<ul>
<li>A party may not send any encrypted data after it processes a <code>&quot;psk&quot;</code> token unless it has previously sent an ephemeral public key (an <code>&quot;e&quot;</code> token), either before or after the <code>&quot;psk&quot;</code> token.</li>
</ul>
<p>This rule guarantees that a <code>k</code> derived from a PSK will never be used for encryption unless it has also been randomized by <code>MixKey(e.public_key)</code> using a self-chosen ephemeral public key.</p>
<h2 id="pattern-modifiers">9.4. Pattern modifiers</h2>
<p>To indicate PSK mode and the placement of the <code>&quot;psk&quot;</code> token, pattern modifiers are used (see <a href="#protocol-names-and-modifiers">Section 8</a>). The modifier <code>psk0</code> places a <code>&quot;psk&quot;</code> token at the beginning of the first handshake message. The modifiers <code>psk1</code>, <code>psk2</code>, etc., place a <code>&quot;psk&quot;</code> token at the end of the first, second, etc., handshake message.</p>
<p>Any pattern using one of these modifiers must process tokens according to the rules in <a href="#handshake-tokens%5D">Section 9.2</a>, and must follow the validity rule in <a href="#validity-rule">Section 9.3</a>.</p>
<p>The table below lists some unmodified one-way patterns on the left, and the recommended PSK pattern on the right:</p>
<table>
<colgroup>
<col width="45%" />
<col width="54%" />
</colgroup>
<tbody>
<tr class="odd">
<td><pre><code>N:
  &lt;- s
  ...
  -&gt; e, es</code></pre></td>
<td><pre><code>   Npsk0:
     &lt;- s
     ...
     -&gt; psk, e, es</code></pre></td>
</tr>
<tr class="even">
<td><pre><code>K:
  -&gt; s
  &lt;- s
  ...
  -&gt; e, es, ss</code></pre></td>
<td><pre><code>   Kpsk0:
     -&gt; s
     &lt;- s
     ...
     -&gt; psk, e, es, ss</code></pre></td>
</tr>
<tr class="odd">
<td><pre><code>X:
  &lt;- s
  ...
  -&gt; e, es, s, ss</code></pre></td>
<td><pre><code>   Xpsk1:
     &lt;- s
     ...
     -&gt; e, es, s, ss, psk</code></pre></td>
</tr>
</tbody>
</table>
<p>Note that the <code>psk1</code> modifier is recommended for <code>X</code>. This is because <code>X</code> transmits the initiator's static public key. Because PSKs are typically pairwise, the responder likely cannot determine the PSK until it has decrypted the initiator's static public key. Thus, <code>psk1</code> is likely to be more useful here than <code>psk0</code>.</p>
<p>Following similar logic, we can define the most likely interactive PSK patterns:</p>
<table>
<colgroup>
<col width="45%" />
<col width="54%" />
</colgroup>
<tbody>
<tr class="odd">
<td><pre><code>NN:
  -&gt; e
  &lt;- e, ee</code></pre></td>
<td><pre><code>NNpsk0:
  -&gt; psk, e
  &lt;- e, ee</code></pre></td>
</tr>
<tr class="even">
<td><pre><code>NN:
  -&gt; e
  &lt;- e, ee</code></pre></td>
<td><pre><code>NNpsk2:
  -&gt; e
  &lt;- e, ee, psk</code></pre></td>
</tr>
<tr class="odd">
<td><pre><code>NK:
  &lt;- s
  ...
  -&gt; e, es
  &lt;- e, ee</code></pre></td>
<td><pre><code>NKpsk0:
  &lt;- s
  ...
  -&gt; psk, e, es
  &lt;- e, ee</code></pre></td>
</tr>
<tr class="even">
<td><pre><code>NK:
  &lt;- s
  ...
  -&gt; e, es
  &lt;- e, ee</code></pre></td>
<td><pre><code>NKpsk2:
  &lt;- s
  ...
  -&gt; e, es
  &lt;- e, ee, psk</code></pre></td>
</tr>
<tr class="odd">
<td><pre><code>NX:
  -&gt; e
  &lt;- e, ee, s, es</code></pre></td>
<td><pre><code> NXpsk2:
   -&gt; e
   &lt;- e, ee, s, es, psk</code></pre></td>
</tr>
<tr class="even">
<td><pre><code>XN:
  -&gt; e
  &lt;- e, ee
  -&gt; s, se</code></pre></td>
<td><pre><code> XNpsk3:
   -&gt; e
   &lt;- e, ee
   -&gt; s, se, psk</code></pre></td>
</tr>
<tr class="odd">
<td><pre><code>XK:
  &lt;- s
  ...
  -&gt; e, es
  &lt;- e, ee
  -&gt; s, se</code></pre></td>
<td><pre><code> XKpsk3:
   &lt;- s
   ...
   -&gt; e, es
   &lt;- e, ee
   -&gt; s, se, psk</code></pre></td>
</tr>
<tr class="even">
<td><pre><code>XX:
  -&gt; e
  &lt;- e, ee, s, es
  -&gt; s, se</code></pre></td>
<td><pre><code> XXpsk3:
   -&gt; e
   &lt;- e, ee, s, es
   -&gt; s, se, psk</code></pre></td>
</tr>
<tr class="odd">
<td><pre><code>KN:
  -&gt; s
  ...
  -&gt; e
  &lt;- e, ee, se</code></pre></td>
<td><pre><code>  KNpsk0:
    -&gt; s
    ...
    -&gt; psk, e
    &lt;- e, ee, se</code></pre></td>
</tr>
<tr class="even">
<td><pre><code>KN:
  -&gt; s
  ...
  -&gt; e
  &lt;- e, ee, se</code></pre></td>
<td><pre><code>  KNpsk2:
    -&gt; s
    ...
    -&gt; e
    &lt;- e, ee, se, psk</code></pre></td>
</tr>
<tr class="odd">
<td><pre><code>KK:
  -&gt; s
  &lt;- s
  ...
  -&gt; e, es, ss
  &lt;- e, ee, se</code></pre></td>
<td><pre><code>  KKpsk0:
    -&gt; s
    &lt;- s
    ...
    -&gt; psk, e, es, ss
    &lt;- e, ee, se</code></pre></td>
</tr>
<tr class="even">
<td><pre><code>KK:
  -&gt; s
  &lt;- s
  ...
  -&gt; e, es, ss
  &lt;- e, ee, se</code></pre></td>
<td><pre><code>  KKpsk2:
    -&gt; s
    &lt;- s
    ...
    -&gt; e, es, ss
    &lt;- e, ee, se, psk</code></pre></td>
</tr>
<tr class="odd">
<td><pre><code>KX:
  -&gt; s
  ...
  -&gt; e
  &lt;- e, ee, se, s, es</code></pre></td>
<td><pre><code>   KXpsk2:
     -&gt; s
     ...
     -&gt; e
     &lt;- e, ee, se, s, es, psk</code></pre></td>
</tr>
<tr class="even">
<td><pre><code>IN:
  -&gt; e, s
  &lt;- e, ee, se</code></pre></td>
<td><pre><code>   INpsk1:
     -&gt; e, s, psk
     &lt;- e, ee, se</code></pre></td>
</tr>
<tr class="odd">
<td><pre><code>IN:
  -&gt; e, s
  &lt;- e, ee, se</code></pre></td>
<td><pre><code>   INpsk2:
     -&gt; e, s
     &lt;- e, ee, se, psk</code></pre></td>
</tr>
<tr class="even">
<td><pre><code>IK:
  &lt;- s
  ...
  -&gt; e, es, s, ss
  &lt;- e, ee, se</code></pre></td>
<td><pre><code>   IKpsk1:
     &lt;- s
     ...
     -&gt; e, es, s, ss, psk
     &lt;- e, ee, se</code></pre></td>
</tr>
<tr class="odd">
<td><pre><code>IK:
  &lt;- s
  ...
  -&gt; e, es, s, ss
  &lt;- e, ee, se</code></pre></td>
<td><pre><code>   IKpsk2:
     &lt;- s
     ...
     -&gt; e, es, s, ss
     &lt;- e, ee, se, psk</code></pre></td>
</tr>
<tr class="even">
<td><pre><code>IX:
  -&gt; e, s
  &lt;- e, ee, se, s, es</code></pre></td>
<td><pre><code>   IXpsk2:
     -&gt; e, s
     &lt;- e, ee, se, s, es, psk</code></pre></td>
</tr>
</tbody>
</table>
<p>The above list does not exhaust all possible patterns that can be formed with these modifiers. In particular, any of these PSK modifiers can be safely applied to any previously named pattern, resulting in patterns like <code>IKpsk0</code>, <code>KKpsk1</code>, or even <code>XXpsk0+psk3</code>, which aren't listed above.</p>
<p>This still doesn't exhaust all the ways that <code>&quot;psk&quot;</code> tokens could be used outside of these modifiers (e.g. placement of <code>&quot;psk&quot;</code> tokens in the middle of a message pattern). Defining additional PSK modifiers is outside the scope of this document.</p>
<h1 id="compound-protocols">10. Compound protocols</h1>
<h2 id="rationale-for-compound-protocols">10.1. Rationale for compound protocols</h2>
<p>So far we've assumed Alice and Bob wish to execute a single Noise protocol chosen by the initiator (Alice). However, there are a number of reasons why Bob might wish to switch to a different Noise protocol after receiving Alice's first message. For example:</p>
<ul>
<li><p>Alice might have chosen a Noise protocol based on a cipher, DH function, or handshake pattern which Bob doesn't support.</p></li>
<li><p>Alice might have sent a &quot;zero-RTT&quot; encrypted initial message based on an out-of-date version of Bob's static public key or PSK.</p></li>
</ul>
<p>Handling these scenarios requires a <strong>compound protocol</strong> where Bob switches from the initial Noise protocol chosen by Alice to a new Noise protocol. In such a compound protocol the roles of initiator and responder would be reversed - Bob would become the initiator of the new Noise protocol, and Alice the responder.</p>
<p>Compound protocols introduce significant complexity as Alice needs to advertise the Noise protocol she is beginning with and the Noise protocol(s) she is capable of switching to, and both parties have to negotiate a secure transition.</p>
<p>These details are largely out of scope for this document. However, to give an example of how compound protocols can be constructed, and to provide some building blocks, the following sections define a <strong><code>fallback</code></strong> modifier and show how it can be used to create a <strong>Noise Pipe</strong> compound protocol.</p>
<p>Noise Pipes support the <code>XX</code> pattern, but also allow Alice to cache Bob's static public key and attempt an <code>IK</code> handshake with 0-RTT encryption.</p>
<p>In case Bob can't decrypt Alice's initial <code>IK</code> message, he will switch to the <code>XXfallback</code> pattern, which essentially allows the parties to complete an <code>XX</code> handshake as if Alice had sent an <code>XX</code> initial message instead of an <code>IK</code> initial message.</p>
<h2 id="the-fallback-modifier">10.2. The <code>fallback</code> modifier</h2>
<p>The <code>fallback</code> modifier converts an Alice-initiated pattern to a Bob-initiated pattern by converting Alice's initial message to a pre-message that Bob must receive through some other means (e.g. via an initial <code>IK</code> message from Alice). After this conversion, the rest of the handshake pattern is interpreted as a Bob-initiated handshake pattern.</p>
<p>For example, here is the <code>fallback</code> modifier applied to <code>XX</code> to produce <code>XXfallback</code>:</p>

<p> </p>
<pre><code>XX:  
  -&gt; e
  &lt;- e, ee, s, es
  -&gt; s, se

XXfallback:                   
  -&gt; e
  ...
  &lt;- e, ee, s, es
  -&gt; s, se</code></pre>
<p>Note that <code>fallback</code> can only be applied to handshake patterns in Alice-initiated form where Alice's first message is capable of being interpreted as a pre-message (i.e. it must be either <code>&quot;e&quot;</code>, <code>&quot;s&quot;</code>, or <code>&quot;e, s&quot;</code>).</p>
<h2 id="zero-rtt-and-noise-protocols">10.3. Zero-RTT and Noise protocols</h2>
<p>A typical compound protocol for zero-RTT encryption involves three different Noise protocols:</p>
<ul>
<li><p>A <strong>full protocol</strong> is used if Alice doesn't possess stored information about Bob that would enable zero-RTT encryption, or doesn't wish to use the zero-RTT handshake.</p></li>
<li><p>A <strong>zero-RTT protocol</strong> allows encryption of data in the initial message.</p></li>
<li><p>A <strong>switch protocol</strong> is triggered by Bob if he can't decrypt Alice's first zero-RTT handshake message.</p></li>
</ul>
<p>There must be some way for Bob to distinguish the full versus zero-RTT cases on receiving the first message. If Alice makes a zero-RTT attempt, there must be some way for her to distinguish the zero-RTT versus switch cases on receiving the response.</p>
<p>For example, each handshake message could be preceded by some negotiation data, such as a <code>type</code> byte (see <a href="#application-responsibilities">Section 13</a>). This data is not part of the Noise message proper, but signals which Noise protocol is being used.</p>
<h2 id="noise-pipes">10.4. Noise Pipes</h2>
<p>This section defines the <strong>Noise Pipe</strong> compound protocol. The following handshake patterns satisfy the full, zero-RTT, and switch roles discussed in the previous section, so can be used to provide a full handshake with a simple zero-RTT option:</p>
<pre><code>XX:  
  -&gt; e
  &lt;- e, ee, s, es
  -&gt; s, se

IK:                   
  &lt;- s                         
  ...
  -&gt; e, es, s, ss          
  &lt;- e, ee, se

XXfallback:                   
  -&gt; e
  ...
  &lt;- e, ee, s, es
  -&gt; s, se</code></pre>
<p>The <code>XX</code> pattern is used for a <strong>full handshake</strong> if the parties haven't communicated before, after which Alice can cache Bob's static public key.</p>
<p>The <code>IK</code> pattern is used for a <strong>zero-RTT handshake</strong>.</p>
<p>The <code>XXfallback</code> pattern is used for a <strong>switch handshake</strong> if Bob fails to decrypt an initial <code>IK</code> message (perhaps due to having changed his static key).</p>
<h2 id="handshake-indistinguishability">10.5. Handshake indistinguishability</h2>
<p>Parties might wish to hide from an eavesdropper which type of handshake they are performing. For example, suppose parties are using Noise Pipes, and want to hide whether they are performing a full handshake, zero-RTT handshake, or fallback handshake.</p>
<p>This is fairly easy:</p>
<ul>
<li><p>The first three messages can have their payloads padded with random bytes to a constant size, regardless of which handshake is executed.</p></li>
<li><p>Bob will attempt to decrypt the first message as an <code>IK</code> message, and will switch to <code>XXfallback</code> if decryption fails.</p></li>
<li><p>An Alice who sends an <code>IK</code> initial message can use trial decryption to differentiate between a response using <code>IK</code> or <code>XXfallback</code>.</p></li>
<li><p>An Alice attempting a full handshake will send an ephemeral public key, then random padding, and will use <code>XXfallback</code> to handle the response. Note that <code>XX</code> isn't used, because the server can't distinguish an <code>XX</code> message from a failed <code>IK</code> attempt by using trial decryption.</p></li>
</ul>
<p>This leaves the Noise ephemeral public keys in the clear. Ephemeral public keys are randomly chosen DH public values, but they will typically have enough structure that an eavesdropper might suspect the parties are using Noise, even if the eavesdropper can't distinguish the different handshakes. To make the ephemerals indistinguishable from random byte sequences, techniques like Elligator <span class="citation">[<a href="#ref-elligator">5</a>]</span> could be used.</p>
<h1 id="advanced-features">11. Advanced features</h1>
<h2 id="dummy-keys">11.1. Dummy keys</h2>
<p>Consider a protocol where an initiator will authenticate herself if the responder requests it. This could be viewed as the initiator choosing between patterns like <code>NX</code> and <code>XX</code> based on some value inside the responder's first handshake payload.</p>
<p>Noise doesn't directly support this. Instead, this could be simulated by always executing <code>XX</code>. The initiator can simulate the <code>NX</code> case by sending a <strong>dummy static public key</strong> if authentication is not requested. The value of the dummy public key doesn't matter.</p>
<p>This technique is simple, since it allows use of a single handshake pattern. It also doesn't reveal which option was chosen from message sizes or computation time. It could be extended to allow an <code>XX</code> pattern to support any permutation of authentications (initiator only, responder only, both, or none).</p>
<p>Similarly, <strong>dummy PSKs</strong> (e.g. a PSK of all zeros) would allow a protocol to optionally support PSKs.</p>
<h2 id="channel-binding">11.2. Channel binding</h2>
<p>Parties might wish to execute a Noise protocol, then perform authentication at the application layer using signatures, passwords, or something else.</p>
<p>To support this, Noise libraries may call <code>GetHandshakeHash()</code> after the handshake is complete and expose the returned value to the application as a <strong>handshake hash</strong> which uniquely identifies the Noise session.</p>
<p>Parties can then sign the handshake hash, or hash it along with their password, to get an authentication token which has a &quot;channel binding&quot; property: the token can't be used by the receiving party with a different sesssion.</p>
<h2 id="rekey">11.3. Rekey</h2>
<p>Parties might wish to periodically update their cipherstate keys using a one-way function, so that a compromise of cipherstate keys will not decrypt older messages. Periodic rekey might also be used to reduce the volume of data encrypted under a single cipher key (this is usually not important with good ciphers, though note the discussion on <code>AESGCM</code> data volumes in <a href="#security-considerations">Section 14</a>).</p>
<p>To enable this, Noise supports a <code>Rekey()</code> function which may be called on a <code>CipherState</code>.</p>
<p>It is up to to the application if and when to perform rekey. For example:</p>
<ul>
<li><p>Applications might perform <strong>continuous rekey</strong>, where they rekey the relevant cipherstate after every transport message sent or received. This is simple and gives good protection to older ciphertexts, but might be difficult for implementations where changing keys is expensive.</p></li>
<li><p>Applications might rekey a cipherstate automatically after it has has been used to send or receive some number of messages.</p></li>
<li><p>Applications might choose to rekey based on arbitrary criteria, in which case they signal this to the other party by sending a message.</p></li>
</ul>
<p>Applications must make these decisions on their own; there are no pattern modifiers which specify rekey behavior.</p>
<p>Note that rekey only updates the cipherstate's <code>k</code> value, it doesn't reset the cipherstate's <code>n</code> value, so applications performing rekey must still perform a new handshake if sending 2<sup>64</sup> or more transport messages.</p>
<h2 id="out-of-order-transport-messages">11.4. Out-of-order transport messages</h2>
<p>In some use cases, Noise transport messages might be lost or arrive out-of-order (e.g. when messages are sent over UDP). To handle this, an application protocol can send the <code>n</code> value used for encrypting each transport message alongside that message. On receiving such a message the recipient would call the <code>SetNonce()</code> function on the receiving <code>CipherState</code> using the received <code>n</code> value.</p>
<p>Recipients doing this must track the received <code>n</code> values for which decryption was successful and reject any message which repeats such a value, to prevent replay attacks.</p>
<p>Note that lossy and out-of-order message delivery introduces many other concerns (including out-of-order handshake messages and denial of service risks) which are outside the scope of this document.</p>
<h2 id="half-duplex-protocols">11.5. Half-duplex protocols</h2>
<p>In some application protocols the parties strictly alternate sending messages. In this case Noise can be used in a <strong>half-duplex</strong> mode <span class="citation">[<a href="#ref-blinker">6</a>]</span> where the first <code>CipherState</code> returned by <code>Split()</code> is used for encrypting messages in both directions, and the second <code>CipherState</code> returned by <code>Split()</code> is unused. This allows some small optimizations, since <code>Split()</code> only has to calculate a single output <code>CipherState</code>, and both parties only need to store a single <code>CipherState</code> during the transport phase.</p>
<p>This feature must be used with extreme caution. In particular, it would be a catastrophic security failure if the protocol is not strictly alternating and both parties encrypt different messages using the same <code>CipherState</code> and nonce value.</p>
<h1 id="dh-functions-cipher-functions-and-hash-functions">12. DH functions, cipher functions, and hash functions</h1>
<h2 id="the-25519-dh-functions">12.1. The <code>25519</code> DH functions</h2>
<ul>
<li><p><strong><code>GENERATE_KEYPAIR()</code></strong>: Returns a new Curve25519 key pair.</p></li>
<li><p><strong><code>DH(keypair, public_key)</code></strong>: Executes the Curve25519 DH function (aka &quot;X25519&quot; in <span class="citation">[<a href="#ref-rfc7748">7</a>]</span>). Invalid public key values will produce an output of all zeros.</p>
<p>Alternatively, implementations are allowed to detect inputs that produce an all-zeros output and signal an error instead. This behavior is discouraged because it adds complexity and implementation variance, and does not improve security. This behavior is allowed because it might match the behavior of some software.</p></li>
<li><p><strong><code>DHLEN</code></strong> = 32</p></li>
</ul>
<h2 id="the-448-dh-functions">12.2. The <code>448</code> DH functions</h2>
<ul>
<li><p><strong><code>GENERATE_KEYPAIR()</code></strong>: Returns a new Curve448 key pair.</p></li>
<li><p><strong><code>DH(keypair, public_key)</code></strong>: Executes the Curve448 DH function (aka &quot;X448&quot; in <span class="citation">[<a href="#ref-rfc7748">7</a>]</span>). Invalid public key values will produce an output of all zeros.</p>
<p>Alternatively, implementations are allowed to detect inputs that produce an all-zeros output and signal an error instead. This behavior is discouraged because it adds complexity and implementation variance, and does not improve security. This behavior is allowed because it might match the behavior of some software.</p></li>
<li><p><strong><code>DHLEN</code></strong> = 56</p></li>
</ul>
<h2 id="the-chachapoly-cipher-functions">12.3. The <code>ChaChaPoly</code> cipher functions</h2>
<ul>
<li><strong><code>ENCRYPT(k, n, ad, plaintext)</code> / <code>DECRYPT(k, n, ad, ciphertext)</code></strong>: <code>AEAD_CHACHA20_POLY1305</code> from <span class="citation">[<a href="#ref-rfc7539">8</a>]</span>. The 96-bit nonce is formed by encoding 32 bits of zeros followed by little-endian encoding of <code>n</code>. (Earlier implementations of ChaCha20 used a 64-bit nonce; with these implementations it's compatible to encode <code>n</code> directly into the ChaCha20 nonce without the 32-bit zero prefix).</li>
</ul>
<h2 id="the-aesgcm-cipher-functions">12.4. The <code>AESGCM</code> cipher functions</h2>
<ul>
<li><strong><code>ENCRYPT(k, n, ad, plaintext)</code> / <code>DECRYPT(k, n, ad, ciphertext)</code></strong>: AES256 with GCM from <span class="citation">[<a href="#ref-nistgcm">9</a>]</span> with a 128-bit tag appended to the ciphertext. The 96-bit nonce is formed by encoding 32 bits of zeros followed by big-endian encoding of <code>n</code>.</li>
</ul>
<h2 id="the-sha256-hash-function">12.5. The <code>SHA256</code> hash function</h2>
<ul>
<li><strong><code>HASH(input)</code></strong>: <code>SHA-256</code> from <span class="citation">[<a href="#ref-nistsha2">10</a>]</span>.</li>
<li><strong><code>HASHLEN</code></strong> = 32</li>
<li><strong><code>BLOCKLEN</code></strong> = 64</li>
</ul>
<h2 id="the-sha512-hash-function">12.6. The <code>SHA512</code> hash function</h2>
<ul>
<li><strong><code>HASH(input)</code></strong>: <code>SHA-512</code> from <span class="citation">[<a href="#ref-nistsha2">10</a>]</span>.</li>
<li><strong><code>HASHLEN</code></strong> = 64</li>
<li><strong><code>BLOCKLEN</code></strong> = 128</li>
</ul>
<h2 id="the-blake2s-hash-function">12.7. The <code>BLAKE2s</code> hash function</h2>
<ul>
<li><strong><code>HASH(input)</code></strong>: <code>BLAKE2s</code> from <span class="citation">[<a href="#ref-rfc7693">11</a>]</span> with digest length 32.</li>
<li><strong><code>HASHLEN</code></strong> = 32</li>
<li><strong><code>BLOCKLEN</code></strong> = 64</li>
</ul>
<h2 id="the-blake2b-hash-function">12.8. The <code>BLAKE2b</code> hash function</h2>
<ul>
<li><strong><code>HASH(input)</code></strong>: <code>BLAKE2b</code> from <span class="citation">[<a href="#ref-rfc7693">11</a>]</span> with digest length 64.</li>
<li><strong><code>HASHLEN</code></strong> = 64</li>
<li><strong><code>BLOCKLEN</code></strong> = 128</li>
</ul>

<h1 id="application-responsibilities">13. Application responsibilities</h1>
<p>An application built on Noise must consider several issues:</p>
<ul>
<li><p><strong>Choosing crypto functions</strong>: The <code>25519</code> DH functions are recommended for typical uses, though the <code>448</code> DH functions might offer extra security in case a cryptanalytic attack is developed against elliptic curve cryptography. The <code>448</code> DH functions should be used with a 512-bit hash like <code>SHA512</code> or <code>BLAKE2b</code>. The <code>25519</code> DH functions may be used with a 256-bit hash like <code>SHA256</code> or <code>BLAKE2s</code>, though a 512-bit hash might offer extra security in case a cryptanalytic attack is developed against the smaller hash functions. <code>AESGCM</code> is hard to implement with high speed and constant time in software.</p></li>
<li><p><strong>Extensibility</strong>: Applications are recommended to use an extensible data format for the payloads of all messages (e.g. JSON, Protocol Buffers). This ensures that fields can be added in the future which are ignored by older implementations.</p></li>
<li><p><strong>Padding</strong>: Applications are recommended to use a data format for the payloads of all encrypted messages that allows padding. This allows implementations to avoid leaking information about message sizes. Using an extensible data format, per the previous bullet, may be sufficient.</p></li>
<li><p><strong>Session termination</strong>: Applications must consider that a sequence of Noise transport messages could be truncated by an attacker. Applications should include explicit length fields or termination signals inside of transport payloads to signal the end of an interactive session, or the end of a one-way stream of transport messages.</p></li>
<li><p><strong>Length fields</strong>: Applications must handle any framing or additional length fields for Noise messages, considering that a Noise message may be up to 65535 bytes in length. If an explicit length field is needed, applications are recommended to add a 16-bit big-endian length field prior to each message.</p></li>
<li><p><strong>Negotiation data</strong>: Applications might wish to support the transmission of some negotiation data prior to the handshake, and/or prior to each handshake message. Negotiation data could contain things like version information and identifiers for Noise protocols. For example, a simple approach would be to send a single-byte type field prior to each Noise handshake message. More flexible approaches might send extensible structures such as protobufs. Negotiation data introduces significant complexity and security risks such as rollback attacks (see next section).</p></li>
</ul>

<h1 id="security-considerations">14. Security considerations</h1>
<p>This section collects various security considerations:</p>
<ul>
<li><p><strong>Authentication</strong>: A Noise protocol with static public keys verifies that the corresponding private keys are possessed by the participant(s), but it's up to the application to determine whether the remote party's static public key is acceptable. Methods for doing so include certificates which sign the public key (and which may be passed in handshake payloads), preconfigured lists of public keys, or &quot;pinning&quot; / &quot;key-continuity&quot; approaches where parties remember public keys they encounter and check whether the same party presents the same public key in the future.</p></li>
<li><p><strong>Session termination</strong>: Preventing attackers from truncating a stream of transport messages is an application responsibility. See previous section.</p></li>
<li><p><strong>Rollback</strong>: If parties decide on a Noise protocol based on some previous negotiation that is not included as prologue, then a rollback attack might be possible. This is a particular risk with compound protocols, and requires careful attention if a Noise handshake is preceded by communication between the parties.</p></li>
<li><p><strong>Static key reuse</strong>: A static key pair used with Noise should be used with a single hash algorithm. The key pair should not be used outside of Noise, nor with multiple hash algorithms. It is acceptable to use the static key pair with different Noise protocols, provided the same hash algorithm is used in all of them. (Reusing a Noise static key pair outside of Noise would require extremely careful analysis to ensure the uses don't compromise each other, and security proofs are preserved).</p></li>
<li><p><strong>PSK reuse</strong>: A PSK used with Noise should be used with a single hash algorithm. The PSK should not be used outside of Noise, nor with multiple hash algorithms.</p></li>
<li><p><strong>Ephemeral key reuse</strong>: Every party in a Noise protocol must send a fresh ephemeral public key prior to sending any encrypted data. Ephemeral keys must never be reused. Violating these rules is likely to cause catastrophic key reuse. This is one rationale behind the patterns in <a href="#handshake-patterns">Section 7</a>, and the validity rules in <a href="#handshake-pattern-validity">Section 7.3</a>. It's also the reason why one-way handshakes only allow transport messages from the sender, not the recipient.</p></li>
<li><p><strong>Misusing public keys as secrets</strong>: It might be tempting to use a pattern with a pre-message public key and assume that a successful handshake implies the other party's knowledge of the public key. Unfortunately, this is not the case, since setting public keys to invalid values might cause predictable DH output. For example, a <code>Noise_NK_25519</code> initiator might send an invalid ephemeral public key to cause a known DH output of all zeros, despite not knowing the responder's static public key. If the parties want to authenticate with a shared secret, it should be used as a PSK.</p></li>
<li><p><strong>Channel binding</strong>: Depending on the DH functions, it might be possible for a malicious party to engage in multiple sessions that derive the same shared secret key by setting public keys to invalid values that cause predictable DH output (as in the previous bullet). It might also be possible to set public keys to equivalent values that cause the same DH output for different inputs. This is why a higher-level protocol should use the handshake hash (<code>h</code>) for a unique channel binding, instead of <code>ck</code>, as explained in <a href="#channel-binding">Section 11.2</a>.</p></li>
<li><p><strong>Incrementing nonces</strong>: Reusing a nonce value for <code>n</code> with the same key <code>k</code> for encryption would be catastrophic. Implementations must carefully follow the rules for nonces. Nonces are not allowed to wrap back to zero due to integer overflow, and the maximum nonce value is reserved. This means parties are not allowed to send more than 2<sup>64</sup>-1 transport messages.</p></li>
<li><p><strong>Protocol names</strong>: The protocol name used with <code>Initialize()</code> must uniquely identify the combination of handshake pattern and crypto functions for every key it's used with (whether ephemeral key pair, static key pair, or PSK). If the same secret key was reused with the same protocol name but a different set of cryptographic operations then bad interactions could occur.</p></li>
<li><p><strong>Pre-shared symmetric keys</strong>: Pre-shared symmetric keys must be secret values with 256 bits of entropy.</p></li>
<li><p><strong>Data volumes</strong>: The <code>AESGCM</code> cipher functions suffer a gradual reduction in security as the volume of data encrypted under a single key increases. Due to this, parties should not send more than 2<sup>56</sup> bytes (roughly 72 petabytes) encrypted by a single key. If sending such large volumes of data is a possibility then different cipher functions should be chosen.</p></li>
<li><p><strong>Hash collisions</strong>: If an attacker can find hash collisions on prologue data or the handshake hash, they may be able to perform &quot;transcript collision&quot; attacks that trick the parties into having different views of handshake data. It is important to use Noise with collision-resistant hash functions, and replace the hash function at any sign of weakness.</p></li>
<li><p><strong>Implementation fingerprinting</strong>: If this protocol is used in settings with anonymous parties, care should be taken that implementations behave identically in all cases. This may require mandating exact behavior for handling of invalid DH public keys.</p></li>
</ul>

<h1 id="rationales">15. Rationales</h1>
<p>This section collects various design rationales.</p>
<h2 id="ciphers-and-encryption">15.1. Ciphers and encryption</h2>
<p>Cipher keys and PSKs are 256 bits because:</p>
<ul>
<li><p>256 bits is a conservative length for cipher keys when considering cryptanalytic safety margins, time/memory tradeoffs, multi-key attacks, rekeying, and quantum attacks.</p></li>
<li><p>Pre-shared key length is fixed to simplify testing and implementation, and to deter users from mistakenly using low-entropy passwords as pre-shared keys.</p></li>
</ul>
<p>Nonces are 64 bits because:</p>
<ul>
<li><p>Some ciphers only have 64 bit nonces (e.g. Salsa20).</p></li>
<li><p>64 bit nonces were used in the initial specification and implementations of ChaCha20, so Noise nonces can be used with these implementations.</p></li>
<li><p>64 bits makes it easy for the entire nonce to be treated as an integer and incremented.</p></li>
<li><p>96 bits nonces (e.g. in RFC 7539) are a confusing size where it's unclear if random nonces are acceptable.</p></li>
</ul>
<p>The authentication data in a ciphertext (i.e. the authentication tag or synthetic IV) is 128 bits because:</p>
<ul>
<li><p>Some algorithms (e.g. GCM) lose more security than an ideal MAC when truncated.</p></li>
<li><p>Noise may be used in a wide variety of contexts, including where attackers can receive rapid feedback on whether guesses for authentication data are correct.</p></li>
<li><p>A single fixed length is simpler than supporting variable-length tags.</p></li>
</ul>
<p>Ciphertexts are required to be indistinguishable from random because:</p>
<ul>
<li>This makes Noise protocols easier to use with random padding (for length-hiding), or for censorship-resistant &quot;unfingerprintable&quot; protocols, or with steganography. However note that ephemeral keys are likely to be distinguishable from random unless a technique such as Elligator <span class="citation">[<a href="#ref-elligator">5</a>]</span> is used.</li>
</ul>
<p>Rekey defaults to using encryption with the nonce 2<sup>64</sup>-1 because:</p>
<ul>
<li>With <code>AESGCM</code> and <code>ChaChaPoly</code> rekey can be computed efficiently (the &quot;encryption&quot; just needs to apply the cipher, and can skip calculation of the authentication tag).</li>
</ul>
<p>Rekey doesn't reset <code>n</code> to zero because:</p>
<ul>
<li><p>Leaving <code>n</code> unchanged is simple.</p></li>
<li><p>If the cipher has a weakness such that repeated rekeying gives rise to a cycle of keys, then letting <code>n</code> advance will avoid catastrophic reuse of the same <code>k</code> and <code>n</code> values.</p></li>
<li><p>Letting <code>n</code> advance puts a bound on the total number of encryptions that can be performed with a set of derived keys.</p></li>
</ul>
<p>The <code>AESGCM</code> data volume limit is 2<sup>56</sup> bytes because:</p>
<ul>
<li>This is 2<sup>52</sup> AES blocks (each block is 16 bytes). The limit is based on the risk of birthday collisions being used to rule out plaintext guesses. The probability an attacker could rule out a random guess on a 2<sup>56</sup> byte plaintext is less than 1 in 1 million (roughly (2<sup>52</sup> * 2<sup>52</sup>) / 2<sup>128</sup>).</li>
</ul>
<p>Cipher nonces are big-endian for <code>AESGCM</code>, and little-endian for <code>ChaCha20</code>, because:</p>
<ul>
<li><p>ChaCha20 uses a little-endian block counter internally.</p></li>
<li><p>AES-GCM uses a big-endian block counter internally.</p></li>
<li><p>It makes sense to use consistent endianness in the cipher code.</p></li>
</ul>
<h2 id="hash-functions-and-hashing">15.2. Hash functions and hashing</h2>
<p>The recommended hash function families are SHA2 and BLAKE2 because:</p>
<ul>
<li><p>SHA2 is widely available and is often used alongside AES.</p></li>
<li><p>BLAKE2 is fast and similar to ChaCha20.</p></li>
</ul>
<p>Hash output lengths of both 256 bits and 512 bits are supported because:</p>
<ul>
<li><p>256-bit hashes provide sufficient collision resistance at the 128-bit security level.</p></li>
<li><p>The 256-bit hashes (SHA-256 and BLAKE2s) require less RAM, and less computation when processing smaller inputs (due to smaller block size), than SHA-512 and BLAKE2b.</p></li>
<li><p>SHA-256 and BLAKE2s are faster on 32-bit processors than the larger hashes, which use 64-bit operations internally.</p></li>
</ul>
<p>The <code>MixKey()</code> design uses HKDF because:</p>
<ul>
<li><p>HKDF is well-known and HKDF &quot;chains&quot; are used in similar ways in other protocols (e.g. Signal, IPsec, TLS 1.3).</p></li>
<li><p>HKDF has a published analysis <span class="citation">[<a href="#ref-hkdfpaper">12</a>]</span>.</p></li>
<li><p>HKDF applies multiple layers of hashing between each <code>MixKey()</code> input. This &quot;extra&quot; hashing might mitigate the impact of hash function weakness.</p></li>
</ul>
<p>HMAC is used with all hash functions instead of allowing hashes to use a more specialized function (e.g. keyed BLAKE2), because:</p>
<ul>
<li><p>HKDF requires the use of HMAC, and some of the HKDF analysis in <span class="citation">[<a href="#ref-hkdfpaper">12</a>]</span> depends on the nested structure of HMAC.</p></li>
<li><p>HMAC is widely used with Merkle-Damgard hashes such as SHA2. SHA3 candidates such as Keccak and BLAKE were required to be suitable with HMAC. Thus, HMAC should be applicable to all widely-used hash functions.</p></li>
<li><p>HMAC applies nested hashing to process each input. This &quot;extra&quot; hashing might mitigate the impact of hash function weakness.</p></li>
<li><p>HMAC (and HKDF) are widely-used constructions. If some weakness is found in a hash function, cryptanalysts will likely analyze that weakness in the context of HMAC and HKDF.</p></li>
<li><p>Applying HMAC consistently is simple, and avoids having custom designs with different cryptanalytic properties when using different hash functions.</p></li>
<li><p>HMAC is easy to build on top of a hash function interface. If a more specialized function (e.g. keyed BLAKE2) can't be implemented using only the underlying hash, then it is not guaranteed to be available everywhere the hash function is available.</p></li>
</ul>
<p><code>MixHash()</code> is used instead of sending all inputs directly through <code>MixKey()</code> because:</p>
<ul>
<li><p><code>MixHash()</code> is more efficient than <code>MixKey()</code>.</p></li>
<li><p><code>MixHash()</code> produces a non-secret <code>h</code> value that might be useful to higher-level protocols, e.g. for channel-binding.</p></li>
</ul>
<p>The <code>h</code> value hashes handshake ciphertext instead of plaintext because:</p>
<ul>
<li><p>This ensures <code>h</code> is a non-secret value that can be used for channel-binding or other purposes without leaking secret information.</p></li>
<li><p>This provides stronger guarantees against ciphertext malleability.</p></li>
</ul>
<h2 id="other">15.3. Other</h2>
<p>Big-endian length fields are recommended because:</p>
<ul>
<li><p>Length fields are likely to be handled by parsing code where big-endian &quot;network byte order&quot; is traditional.</p></li>
<li><p>Some ciphers use big-endian internally (e.g. GCM, SHA2).</p></li>
<li><p>While it's true that Curve25519, Curve448, and ChaCha20/Poly1305 use little-endian, these will likely be handled by specialized libraries, so there's not a strong argument for aligning with them.</p></li>
</ul>
<p>Session termination is left to the application because:</p>
<ul>
<li><p>Providing a termination signal in Noise doesn't help the application much, since the application still has to use the signal correctly.</p></li>
<li><p>For an application with its own termination signal, having a second termination signal in Noise is likely to be confusing rather than helpful.</p></li>
</ul>
<p>Explicit random nonces (like TLS &quot;Random&quot; fields) are not used because:</p>
<ul>
<li><p>One-time ephemeral public keys make explicit nonces unnecessary.</p></li>
<li><p>Explicit nonces allow reuse of ephemeral public keys. However reusing ephemerals (with periodic replacement) is more complicated, requires a secure time source, is less secure in case of ephemeral compromise, and only provides a small optimization, since key generation can be done for a fraction of the cost of a DH operation.</p></li>
<li><p>Explicit nonces increase message size.</p></li>
<li><p>Explicit nonces make it easier to &quot;backdoor&quot; crypto implementations, e.g. by modifying the RNG so that key recovery data is leaked through the nonce fields.</p></li>
</ul>
<h1 id="ipr">16. IPR</h1>
<p>The Noise specification (this document) is hereby placed in the public domain.</p>

<h1 id="acknowledgements">17. Acknowledgements</h1>
<p>Noise is inspired by:</p>
<ul>
<li>The NaCl and CurveCP protocols from Dan Bernstein et al <span class="citation">[<a href="#ref-nacl">13</a>], [<a href="#ref-curvecp">14</a>]</span>.</li>
<li>The SIGMA and HOMQV protocols from Hugo Krawczyk <span class="citation">[<a href="#ref-sigma">15</a>], [<a href="#ref-homqv">16</a>]</span>.</li>
<li>The Ntor protocol from Ian Goldberg et al <span class="citation">[<a href="#ref-ntor">17</a>]</span>.</li>
<li>The analysis of OTR by Mario Di Raimondo et al <span class="citation">[<a href="#ref-otr">18</a>]</span>.</li>
<li>The analysis by Caroline Kudla and Kenny Paterson of &quot;Protocol 4&quot; by Simon Blake-Wilson et al <span class="citation">[<a href="#ref-kudla2005">19</a>], [<a href="#ref-blakewilson1997">20</a>]</span>.</li>
<li>Mike Hamburg's proposals for a sponge-based protocol framework, which led to STROBE <span class="citation">[<a href="#ref-moderncryptostrobe">21</a>], [<a href="#ref-strobe">22</a>]</span>.</li>
<li>The KDF chains used in the Double Ratchet Algorithm <span class="citation">[<a href="#ref-doubleratchet">23</a>]</span>.</li>
</ul>
<p>General feedback on the spec and design came from: Moxie Marlinspike, Jason Donenfeld, Rhys Weatherley, Mike Hamburg, David Wong, Jake McGinty, Tiffany Bennett, Jonathan Rudenberg, Stephen Touset, Tony Arcieri, Alex Wied, Alexey Ermishkin, Olaoluwa Osuntokun, Karthik Bhargavan, and Nadim Kobeissi.</p>
<p>Helpful editorial feedback came from: Tom Ritter, Karthik Bhargavan, David Wong, Klaus Hartke, Dan Burkert, Jake McGinty, Yin Guanhao, Nazar Mokrynskyi, Keziah Elis Biermann, Justin Cormack, Katriel Cohn-Gordon, and Nadim Kobeissi.</p>
<p>Helpful input and feedback on the key derivation design came from: Moxie Marlinspike, Hugo Krawczyk, Samuel Neves, Christian Winnerlein, J.P. Aumasson, and Jason Donenfeld.</p>
<p>The PSK approach was largely motivated and designed by Jason Donenfeld, based on his experience with PSKs in WireGuard.</p>
<p>The deferred patterns resulted from discussions with Justin Cormack. The pattern derivation rules in the Appendix are also from Justin Cormack.</p>
<p>The security properties table for deferred patterns was derived by the Noise Explorer tool, from Nadim Kobeissi.</p>
<p>The rekey design benefited from discussions with Rhys Weatherley, Alexey Ermishkin, and Olaoluwa Osuntokun.</p>
<p>The BLAKE2 team (in particular J.P. Aumasson, Samuel Neves, and Zooko) provided helpful discussion on using BLAKE2 with Noise.</p>
<p>Jeremy Clark, Thomas Ristenpart, and Joe Bonneau gave feedback on earlier versions.</p>

<h1 id="appendices">18. Appendices</h1>
<h2 id="deferred-patterns">18.1. Deferred patterns</h2>
<p>The following table lists all 23 deferred handshake patterns in the right column, with their corresponding fundamental handshake pattern in the left column. See <a href="#handshake-patterns">Section 7</a> for an explanation of fundamental and deferred patterns.</p>
<table style="width:85%;">
<colgroup>
<col width="38%" />
<col width="45%" />
</colgroup>
<tbody>
<tr class="odd">
<td><pre><code>NK:
  &lt;- s
  ...
  -&gt; e, es
  &lt;- e, ee</code></pre></td>
<td><pre><code>    NK1:
      &lt;- s
      ...
      -&gt; e
      &lt;- e, ee, es</code></pre></td>
</tr>
<tr class="even">
<td><pre><code>NX:
  -&gt; e
  &lt;- e, ee, s, es</code></pre></td>
<td><pre><code>    NX1:
      -&gt; e
      &lt;- e, ee, s
      -&gt; es</code></pre></td>
</tr>
<tr class="odd">
<td><pre><code>XN:
  -&gt; e
  &lt;- e, ee
  -&gt; s, se</code></pre></td>
<td><pre><code>    X1N:
      -&gt; e
      &lt;- e, ee
      -&gt; s
      &lt;- se</code></pre></td>
</tr>
<tr class="even">
<td><pre><code>XK:
  &lt;- s
  ...
  -&gt; e, es
  &lt;- e, ee
  -&gt; s, se</code></pre></td>
<td><pre><code>    X1K:
      &lt;- s
      ...
      -&gt; e, es
      &lt;- e, ee
      -&gt; s
      &lt;- se

    XK1:
      &lt;- s
      ...
      -&gt; e
      &lt;- e, ee, es
      -&gt; s, se

    X1K1:
      &lt;- s
      ...
      -&gt; e
      &lt;- e, ee, es
      -&gt; s
      &lt;- se</code></pre></td>
</tr>
<tr class="odd">
<td><pre><code>XX:
  -&gt; e
  &lt;- e, ee, s, es
  -&gt; s, se</code></pre></td>
<td><pre><code>    X1X:
      -&gt; e
      &lt;- e, ee, s, es
      -&gt; s
      &lt;- se

    XX1:
      -&gt; e
      &lt;- e, ee, s
      -&gt; es, s, se

    X1X1:
      -&gt; e
      &lt;- e, ee, s
      -&gt; es, s
      &lt;- se</code></pre></td>
</tr>
<tr class="even">
<td><pre><code>KN:
  -&gt; s
  ...
  -&gt; e
  &lt;- e, ee, se</code></pre></td>
<td><pre><code>    K1N:
      -&gt; s
      ...
      -&gt; e
      &lt;- e, ee
      -&gt; se</code></pre></td>
</tr>
<tr class="odd">
<td><pre><code>KK:
  -&gt; s
  &lt;- s
  ...
  -&gt; e, es, ss
  &lt;- e, ee, se</code></pre></td>
<td><pre><code>    K1K:
      -&gt; s
      &lt;- s
      ...
      -&gt; e, es
      &lt;- e, ee
      -&gt; se

    KK1:
      -&gt; s
      &lt;- s
      ...
      -&gt; e
      &lt;- e, ee, se, es

    K1K1:
      -&gt; s
      &lt;- s
      ...
      -&gt; e
      &lt;- e, ee, es
      -&gt; se</code></pre></td>
</tr>
<tr class="even">
<td><pre><code>KX:
  -&gt; s
  ...
  -&gt; e
  &lt;- e, ee, se, s, es</code></pre></td>
<td><pre><code>    K1X:
      -&gt; s
      ...
      -&gt; e
      &lt;- e, ee, s, es
      -&gt; se

    KX1:
      -&gt; s
      ...
      -&gt; e
      &lt;- e, ee, se, s
      -&gt; es

    K1X1:
      -&gt; s
      ...
      -&gt; e
      &lt;- e, ee, s
      -&gt; se, es</code></pre></td>
</tr>
<tr class="odd">
<td><pre><code>IN:
  -&gt; e, s
  &lt;- e, ee, se</code></pre></td>
<td><pre><code>    I1N:
      -&gt; e, s
      &lt;- e, ee
      -&gt; se</code></pre></td>
</tr>
<tr class="even">
<td><pre><code>IK:
  &lt;- s
  ...
  -&gt; e, es, s, ss
  &lt;- e, ee, se</code></pre></td>
<td><pre><code>    I1K:
      &lt;- s
      ...
      -&gt; e, es, s
      &lt;- e, ee
      -&gt; se

    IK1:
      &lt;- s
      ...
      -&gt; e, s
      &lt;- e, ee, se, es

    I1K1:
      &lt;- s
      ...
      -&gt; e, s
      &lt;- e, ee, es
      -&gt; se</code></pre></td>
</tr>
<tr class="odd">
<td><pre><code>IX:
  -&gt; e, s
  &lt;- e, ee, se, s, es</code></pre></td>
<td><pre><code>    I1X:
      -&gt; e, s
      &lt;- e, ee, s, es
      -&gt; se

    IX1:
      -&gt; e, s
      &lt;- e, ee, se, s
      -&gt; es

    I1X1:
      -&gt; e, s
      &lt;- e, ee, s
      -&gt; se, es</code></pre></td>
</tr>
</tbody>
</table>

<h2 id="security-properties-for-deferred-patterns">18.2. Security properties for deferred patterns</h2>
<p>The following table lists the the security properties for the Noise handshake and transport payloads for all the deferred patterns in the previous section. The security properties are labelled using the notation from <a href="#payload-security-properties">Section 7.7</a>.</p>
<table style="width:88%;">
<colgroup>
<col width="87%" />
</colgroup>
<tbody>
<tr class="odd">
<td><pre><code>                         Source         Destination</code></pre></td>
</tr>
<tr class="even">
<td><pre><code>NK1
  &lt;- s
  ...
  -&gt; e                      0                0
  &lt;- e, ee, es              2                1
  -&gt;                        0                5</code></pre></td>
</tr>
<tr class="odd">
<td><pre><code>NX1
  -&gt; e                      0                0
  &lt;- e, ee, s               0                1
  -&gt; es                     0                3
  -&gt;                        2                1
  &lt;-                        0                5</code></pre></td>
</tr>
<tr class="even">
<td><pre><code>X1N
  -&gt; e                      0                0
  &lt;- e, ee                  0                1
  -&gt; s                      0                1
  &lt;- se                     0                3
  -&gt;                        2                1</code></pre></td>
</tr>
<tr class="odd">
<td><pre><code>X1K
  &lt;- s
  ...
  -&gt; e, es                  0                2
  &lt;- e, ee                  2                1
  -&gt; s                      0                5
  &lt;- se                     2                3
  -&gt;                        2                5
  &lt;-                        2                5</code></pre></td>
</tr>
<tr class="even">
<td><pre><code>XK1
  &lt;- s
  ...
  -&gt; e                      0                0
  &lt;- e, ee, es              2                1
  -&gt; s, se                  2                5
  &lt;-                        2                5</code></pre></td>
</tr>
<tr class="odd">
<td><pre><code>X1K1
  &lt;- s
  ...
  -&gt; e                      0                0
  &lt;- e, ee, es              2                1
  -&gt; s                      0                5
  &lt;- se                     2                3
  -&gt;                        2                5
  &lt;-                        2                5</code></pre></td>
</tr>
<tr class="even">
<td><pre><code>X1X
  -&gt; e                      0                0
  &lt;- e, ee, s, es           2                1
  -&gt; s                      0                5
  &lt;- se                     2                3
  -&gt;                        2                5
  &lt;-                        2                5</code></pre></td>
</tr>
<tr class="odd">
<td><pre><code>XX1
  -&gt; e                      0                0
  &lt;- e, ee, s               0                1
  -&gt; es, s, se              2                3
  &lt;-                        2                5
  -&gt;                        2                5</code></pre></td>
</tr>
<tr class="even">
<td><pre><code>X1X1
  -&gt; e                      0                0
  &lt;- e, ee, s               0                1
  -&gt; es, s                  0                3
  &lt;- se                     2                3
  -&gt;                        2                5
  &lt;-                        2                5</code></pre></td>
</tr>
<tr class="odd">
<td><pre><code>K1N
  -&gt; s
  ...
  -&gt; e                      0                0
  &lt;- e, ee                  0                1
  -&gt; se                     2                1
  &lt;-                        0                5</code></pre></td>
</tr>
<tr class="even">
<td><pre><code>K1K
  -&gt; s
  &lt;- s
  ...
  -&gt; e, es                  0                2
  &lt;- e, ee, se              2                1
  -&gt; se                     2                5
  &lt;-                        2                5</code></pre></td>
</tr>
<tr class="odd">
<td><pre><code>KK1
  -&gt; s
  &lt;- s
  ...
  -&gt; e                      0                0
  &lt;- e, ee, se, es          2                3
  -&gt;                        2                5
  &lt;-                        2                5</code></pre></td>
</tr>
<tr class="even">
<td><pre><code>K1K1
  -&gt; s
  &lt;- s
  ...
  -&gt; e                      0                0
  &lt;- e, ee, es              2                1
  -&gt; se                     2                5
  &lt;-                        2                5</code></pre></td>
</tr>
<tr class="odd">
<td><pre><code>K1X
  -&gt; s
  ...
  -&gt; e                      0                0
  &lt;- e, ee, s, es           2                1
  -&gt; se                     2                5
  &lt;-                        2                5</code></pre></td>
</tr>
<tr class="even">
<td><pre><code>KX1
  -&gt; s
  ...
  -&gt; e                      0                0
  &lt;- e, ee, se, s           0                3
  -&gt; es                     2                3
  &lt;-                        2                5
  -&gt;                        2                5</code></pre></td>
</tr>
<tr class="odd">
<td><pre><code>K1X1
  -&gt; s
  ...
  -&gt; e                      0                0
  &lt;- e, ee, s               0                1
  -&gt; se, es                 2                3
  &lt;-                        2                5
  -&gt;                        2                5</code></pre></td>
</tr>
<tr class="even">
<td><pre><code>I1N
  -&gt; e, s                   0                0
  &lt;- e, ee                  0                1
  -&gt; se                     2                1
  &lt;-                        0                5</code></pre></td>
</tr>
<tr class="odd">
<td><pre><code>I1K
  &lt;- s
  ...
  -&gt; e, es, s               0                2
  &lt;- e, ee                  2                1
  -&gt; se                     2                5
  &lt;-                        2                5</code></pre></td>
</tr>
<tr class="even">
<td><pre><code>IK1
  &lt;- s
  ...
  -&gt; e, s                   0                0
  &lt;- e, ee, se, es          2                3
  -&gt;                        2                5
  &lt;-                        2                5</code></pre></td>
</tr>
<tr class="odd">
<td><pre><code>I1K1
  &lt;- s
  ...
  -&gt; e, s                   0                0
  &lt;- e, ee, es              2                1
  -&gt; se                     2                5
  &lt;-                        2                5</code></pre></td>
</tr>
<tr class="even">
<td><pre><code>I1X
  -&gt; e, s                   0                0
  &lt;- e, ee, s, es           2                1
  -&gt; se                     2                5
  &lt;-                        2                5</code></pre></td>
</tr>
<tr class="odd">
<td><pre><code>IX1
  -&gt; e, s                   0                0
  &lt;- e, ee, se, s           0                3
  -&gt; es                     2                3
  &lt;-                        2                5
  -&gt;                        2                5</code></pre></td>
</tr>
<tr class="even">
<td><pre><code>I1X1
  -&gt; e, s                   0                0
  &lt;- e, ee, s               0                1
  -&gt; se, es                 2                3
  &lt;-                        2                5
  -&gt;                        2                5</code></pre></td>
</tr>
</tbody>
</table>
<h2 id="pattern-derivation-rules">18.3. Pattern derivation rules</h2>
<p>The following rules were used to derive the one-way, fundamental, and deferred handshake patterns.</p>
<p>First, populate the pre-message contents as defined by the pattern name.</p>
<p>Next populate the initiator's first message by applying the first rule from the below table which matches. Then delete the matching rule and repeat this process until no more rules can be applied. If this is a one-way pattern, it is now complete.</p>
<p>Otherwise, populate the responder's first message in the same way. Once no more responder rules can be applied, then switch to the initiator's next message and repeat this process, switching messages until no more rules can be applied by either party.</p>
<p><strong>Initiator rules:</strong></p>
<ol style="list-style-type: decimal">
<li>Send <code>&quot;e&quot;</code>.</li>
<li>Perform <code>&quot;ee&quot;</code> if <code>&quot;e&quot;</code> has been sent, and received.</li>
<li>Perform <code>&quot;se&quot;</code> if <code>&quot;s&quot;</code> has been sent, and <code>&quot;e&quot;</code> received. If initiator authentication is deferred, skip this rule for the first message in which it applies, then mark the initiator authentication as non-deferred.</li>
<li>Perform <code>&quot;es&quot;</code> if <code>&quot;e&quot;</code> has been sent, and <code>&quot;s&quot;</code> received. If responder authentication is deferred, skip this rule for the first message in which it applies, then mark the responder authentication as non-deferred.</li>
<li>Perform <code>&quot;ss&quot;</code> if <code>&quot;s&quot;</code> has been sent, and received, and <code>&quot;es&quot;</code> has been performed, and this is the first message, and initiator authentication is not deferred.</li>
<li>Send <code>&quot;s&quot;</code> if this is the first message and initiator is &quot;I&quot; or one-way &quot;X&quot;.</li>
<li>Send <code>&quot;s&quot;</code> if this is not the first message and initiator is &quot;X&quot;.</li>
</ol>
<p><strong>Responder rules:</strong></p>
<ol style="list-style-type: decimal">
<li>Send <code>&quot;e&quot;</code>.</li>
<li>Perform <code>&quot;ee&quot;</code> if <code>&quot;e&quot;</code> has been sent, and received.</li>
<li>Perform <code>&quot;se&quot;</code> if <code>&quot;e&quot;</code> has been sent, and <code>&quot;s&quot;</code> received. If initiator authentication is deferred, skip this rule for the first message in which it applies, then mark the initiator authentication as non-deferred.</li>
<li>Perform <code>&quot;es&quot;</code> if <code>&quot;s&quot;</code> has been sent, and <code>&quot;e&quot;</code> received. If responder authentication is deferred, skip this rule for the first message in which it applies, then mark the responder authentication as non-deferred.</li>
<li>Send <code>&quot;s&quot;</code> if responder is &quot;X&quot;.</li>
</ol>

<h2 id="change-log">18.4. Change log</h2>
<p><strong>Revision 34:</strong></p>
<ul>
<li><p>Added official/unstable marking; the unstable only refers to the new deferred patterns, the rest of this document is considered stable.</p></li>
<li><p>Clarified DH() definition so that the identity element is an invalid value (not a generator), thus may be rejected.</p></li>
<li><p>Clarified ciphertext-indistinguishability requirement for AEAD schemes and added a rationale.</p></li>
<li><p>Clarified the order of hashing pre-message public keys.</p></li>
<li><p>Rewrote handshake patterns explanation for clarity.</p></li>
<li><p>Added new validity rule to disallow repeating the same DH operation.</p></li>
<li><p>Clarified the complex validity rule regarding ephemeral keys and key re-use.</p></li>
<li><p>Removed parenthesized list of keys from pattern notation, as it was redundant.</p></li>
<li><p>Added deferred patterns.</p></li>
<li><p>Renamed &quot;Authentication&quot; and &quot;Confidentiality&quot; security properties to &quot;Source&quot; and &quot;Destination&quot; to avoid confusion.</p></li>
<li><p><strong>[SECURITY]</strong> Added a new identity-hiding property, and changed identity-hiding property 3 to discuss an identity equality-check attack.</p></li>
<li><p>Replaced &quot;fallback patterns&quot; concept with Bob-initiated pattern notation.</p></li>
<li><p>Rewrote section on compound protocols and pipes for clarity, including clearer distinction between &quot;switch protocol&quot; and &quot;fallback patterns&quot;.</p></li>
<li><p>De-emphasized &quot;type byte&quot; suggestion, and added a more general discussion of negotiation data.</p></li>
<li><p><strong>[SECURITY]</strong> Added security considerations regarding static key reuse and PSK reuse.</p></li>
<li><p>Added pattern derivation rules to Appendix.</p></li>
</ul>

<h1 id="references" class="unnumbered">19. References</h1>
<div id="refs" class="references">
<div id="ref-Rogaway:2002">
<p>[1] P. Rogaway, “Authenticated-encryption with Associated-data,” in Proceedings of the 9th ACM Conference on Computer and Communications Security, 2002. <a href="http://web.cs.ucdavis.edu/~rogaway/papers/ad.pdf" class="uri">http://web.cs.ucdavis.edu/~rogaway/papers/ad.pdf</a></p>
</div>
<div id="ref-gapdh">
<p>[2] Okamoto, Tatsuaki and Pointcheval, David, “The Gap-Problems: A New Class of Problems for the Security of Cryptographic Schemes,” in Proceedings of the 4th International Workshop on Practice and Theory in Public Key Cryptography: Public Key Cryptography, 2001. <a href="https://www.di.ens.fr/~pointche/Documents/Papers/2001_pkc.pdf" class="uri">https://www.di.ens.fr/~pointche/Documents/Papers/2001_pkc.pdf</a></p>
</div>
<div id="ref-rfc2104">
<p>[3] H. Krawczyk, M. Bellare, and R. Canetti, “HMAC: Keyed-Hashing for Message Authentication.” Internet Engineering Task Force; RFC 2104 (Informational); IETF, Feb-1997. <a href="http://www.ietf.org/rfc/rfc2104.txt" class="uri">http://www.ietf.org/rfc/rfc2104.txt</a></p>
</div>
<div id="ref-rfc5869">
<p>[4] H. Krawczyk and P. Eronen, “HMAC-based Extract-and-Expand Key Derivation Function (HKDF).” Internet Engineering Task Force; RFC 5869 (Informational); IETF, May-2010. <a href="http://www.ietf.org/rfc/rfc5869.txt" class="uri">http://www.ietf.org/rfc/rfc5869.txt</a></p>
</div>
<div id="ref-elligator">
<p>[5] D. J. Bernstein, M. Hamburg, A. Krasnova, and T. Lange, “Elligator: Elliptic-curve points indistinguishable from uniform random strings.” Cryptology ePrint Archive, Report 2013/325, 2013. <a href="http://eprint.iacr.org/2013/325" class="uri">http://eprint.iacr.org/2013/325</a></p>
</div>
<div id="ref-blinker">
<p>[6] Markku-Juhani O. Saarinen, “Beyond Modes: Building a Secure Record Protocol from a Cryptographic Sponge Permutation.” Cryptology ePrint Archive, Report 2013/772, 2013. <a href="http://eprint.iacr.org/2013/772" class="uri">http://eprint.iacr.org/2013/772</a></p>
</div>
<div id="ref-rfc7748">
<p>[7] A. Langley, M. Hamburg, and S. Turner, “Elliptic Curves for Security.” Internet Engineering Task Force; RFC 7748 (Informational); IETF, Jan-2016. <a href="http://www.ietf.org/rfc/rfc7748.txt" class="uri">http://www.ietf.org/rfc/rfc7748.txt</a></p>
</div>
<div id="ref-rfc7539">
<p>[8] Y. Nir and A. Langley, “ChaCha20 and Poly1305 for IETF Protocols.” Internet Engineering Task Force; RFC 7539 (Informational); IETF, May-2015. <a href="http://www.ietf.org/rfc/rfc7539.txt" class="uri">http://www.ietf.org/rfc/rfc7539.txt</a></p>
</div>
<div id="ref-nistgcm">
<p>[9] M. J. Dworkin, “SP 800-38D. Recommendation for Block Cipher Modes of Operation: Galois/Counter Mode (GCM) and GMAC,” National Institute of Standards &amp; Technology, Gaithersburg, MD, United States, 2007. <a href="http://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38d.pdf" class="uri">http://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38d.pdf</a></p>
</div>
<div id="ref-nistsha2">
<p>[10] NIST, “FIPS 180-4. Secure Hash Standard (SHS),” National Institute of Standards &amp; Technology, Gaithersburg, MD, United States, 2012. <a href="http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf" class="uri">http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf</a></p>
</div>
<div id="ref-rfc7693">
<p>[11] M.-J. Saarinen and J.-P. Aumasson, “The BLAKE2 Cryptographic Hash and Message Authentication Code (MAC).” Internet Engineering Task Force; RFC 7693 (Informational); IETF, Nov-2015. <a href="http://www.ietf.org/rfc/rfc7693.txt" class="uri">http://www.ietf.org/rfc/rfc7693.txt</a></p>
</div>
<div id="ref-hkdfpaper">
<p>[12] H. Krawczyk, “‘Cryptographic extraction and key derivation: The hkdf scheme’.” Cryptology ePrint Archive, Report 2010/264, 2010. <a href="http://eprint.iacr.org/2010/264" class="uri">http://eprint.iacr.org/2010/264</a></p>
</div>
<div id="ref-nacl">
<p>[13] D. J. Bernstein, T. Lange, and P. Schwabe, “NaCl: Networking and Cryptography Library.”. <a href="https://nacl.cr.yp.to/" class="uri">https://nacl.cr.yp.to/</a></p>
</div>
<div id="ref-curvecp">
<p>[14] D. J. Bernstein, “CurveCP: Usable security for the Internet.”. <a href="https://curvecp.org" class="uri">https://curvecp.org</a></p>
</div>
<div id="ref-sigma">
<p>[15] H. Krawczyk, “SIGMA: The ‘SIGn-and-MAc’ Approach to Authenticated Diffie-Hellman and Its Use in the IKE Protocols,” in Advances in Cryptology - CRYPTO 2003, 2003. <a href="http://webee.technion.ac.il/~hugo/sigma.html" class="uri">http://webee.technion.ac.il/~hugo/sigma.html</a></p>
</div>
<div id="ref-homqv">
<p>[16] S. Halevi and H. Krawczyk, “One-Pass HMQV and Asymmetric Key-Wrapping.” Cryptology ePrint Archive, Report 2010/638, 2010. <a href="http://eprint.iacr.org/2010/638" class="uri">http://eprint.iacr.org/2010/638</a></p>
</div>
<div id="ref-ntor">
<p>[17] I. Goldberg, D. Stebila, and B. Ustaoglu, “Anonymity and One-way Authentication in Key Exchange Protocols,” Design, Codes, and Cryptography, vol. 67, no. 2, May 2013. <a href="http://cacr.uwaterloo.ca/techreports/2011/cacr2011-11.pdf" class="uri">http://cacr.uwaterloo.ca/techreports/2011/cacr2011-11.pdf</a></p>
</div>
<div id="ref-otr">
<p>[18] M. Di Raimondo, R. Gennaro, and H. Krawczyk, “Secure Off-the-record Messaging,” in Proceedings of the 2005 ACM Workshop on Privacy in the Electronic Society, 2005. <a href="http://www.dmi.unict.it/diraimondo/web/wp-content/uploads/papers/otr.pdf" class="uri">http://www.dmi.unict.it/diraimondo/web/wp-content/uploads/papers/otr.pdf</a></p>
</div>
<div id="ref-kudla2005">
<p>[19] C. Kudla and K. G. Paterson, “Modular Security Proofs for Key Agreement Protocols,” in Advances in Cryptology - ASIACRYPT 2005: 11th International Conference on the Theory and Application of Cryptology and Information Security, 2005. <a href="http://www.isg.rhul.ac.uk/~kp/ModularProofs.pdf" class="uri">http://www.isg.rhul.ac.uk/~kp/ModularProofs.pdf</a></p>
</div>
<div id="ref-blakewilson1997">
<p>[20] S. Blake-Wilson, D. Johnson, and A. Menezes, “Key agreement protocols and their security analysis,” in Crytography and Coding: 6th IMA International Conference Cirencester, UK, December 17–19, 1997 Proceedings, 1997. <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.25.387" class="uri">http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.25.387</a></p>
</div>
<div id="ref-moderncryptostrobe">
<p>[21] M. Hamburg, “Key Exchange and DuplexWrap-like protocols.” Noise@moderncrypto.org Mailing List, 2015. <a href="https://moderncrypto.org/mail-archive/noise/2015/000098.html" class="uri">https://moderncrypto.org/mail-archive/noise/2015/000098.html</a></p>
</div>
<div id="ref-strobe">
<p>[22] Mike Hamburg, “The STROBE protocol framework.” Cryptology ePrint Archive, Report 2017/003, 2017. <a href="http://eprint.iacr.org/2017/003" class="uri">http://eprint.iacr.org/2017/003</a></p>
</div>
<div id="ref-doubleratchet">
<p>[23] T. Perrin and M. Marlinspike, “The Double Ratchet Algorithm,” 2016. <a href="https://whispersystems.org/docs/specifications/doubleratchet/" class="uri">https://whispersystems.org/docs/specifications/doubleratchet/</a></p>
</div>
</div>
</body>
</html>
